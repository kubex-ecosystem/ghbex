# LookAtni Code - Gerado automaticamente
# Data: 2025-08-15T09:39:30.813Z
# Fonte: ./
# Total de arquivos: 18

/// cmd/cli/common.go ///
// Package cli provides common functionality for command-line interface applications.
package cli

import (
	"math/rand"
	"os"
	"strings"
)

var banners = []string{
	`
  ______  __    __ __
 /      \|  \  |  \  \
|  ▓▓▓▓▓▓\ ▓▓  | ▓▓ ▓▓____   ______  __    __
| ▓▓ __\▓▓ ▓▓__| ▓▓ ▓▓    \ /      \|  \  /  \
| ▓▓|    \ ▓▓    ▓▓ ▓▓▓▓▓▓▓\  ▓▓▓▓▓▓\\▓▓\/  ▓▓
| ▓▓ \▓▓▓▓ ▓▓▓▓▓▓▓▓ ▓▓  | ▓▓ ▓▓    ▓▓ >▓▓  ▓▓
| ▓▓__| ▓▓ ▓▓  | ▓▓ ▓▓__/ ▓▓ ▓▓▓▓▓▓▓▓/  ▓▓▓▓\
 \▓▓    ▓▓ ▓▓  | ▓▓ ▓▓    ▓▓\▓▓     \  ▓▓ \▓▓\
  \▓▓▓▓▓▓ \▓▓   \▓▓\▓▓▓▓▓▓▓  \▓▓▓▓▓▓▓\▓▓   \▓▓
`,
}

func GetDescriptions(descriptionArg []string, _ bool) map[string]string {
	var description, banner string

	if descriptionArg != nil {
		if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
			description = descriptionArg[0]
		} else {
			description = descriptionArg[1]
		}
	} else {
		description = ""
	}

	bannerRandLen := len(banners)
	bannerRandIndex := rand.Intn(bannerRandLen)
	banner = banners[bannerRandIndex]

	return map[string]string{"banner": banner, "description": description}
}

/// cmd/cli/server.go ///
package cli

import (
	"context"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/google/go-github/v61/github"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/rafa-mori/ghbex/internal/githubx"
	"github.com/rafa-mori/ghbex/internal/notify"
	"github.com/rafa-mori/ghbex/internal/sanitize"
)

type cfgRoot struct {
	Runtime struct {
		DryRun    bool   `yaml:"dry_run"`
		ReportDir string `yaml:"report_dir"`
	} `yaml:"runtime"`
	Server struct {
		Addr string `yaml:"addr"`
	} `yaml:"server"`
	GitHub struct {
		Auth struct {
			Kind           string `yaml:"kind"` // pat|app
			Token          string `yaml:"token"`
			AppID          int64  `yaml:"app_id"`
			InstallationID int64  `yaml:"installation_id"`
			PrivateKeyPath string `yaml:"private_key_path"`
			BaseURL        string `yaml:"base_url"`
			UploadURL      string `yaml:"upload_url"`
		} `yaml:"auth"`
		Repos []sanitize.RepoCfg `yaml:"repos"`
	} `yaml:"github"`
	Notifiers []struct {
		Type    string `yaml:"type"`
		Webhook string `yaml:"webhook"`
	} `yaml:"notifiers"`
}

func ServerCmdList() []*cobra.Command {
	var cmds []*cobra.Command

	// Define your server commands here
	cmds = append(cmds, startServer())
	cmds = append(cmds, stopServer())
	cmds = append(cmds, statusServer())
	return cmds
}

func stopServer() *cobra.Command {
	stopCmd := &cobra.Command{
		Use:   "stop",
		Short: "Stop the server",
		Annotations: GetDescriptions([]string{
			"This command stops server.",
			"This command stops the Grompt server and releases any resources held by it.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			// Stop server logic
		},
	}
	return stopCmd
}

func statusServer() *cobra.Command {
	statusCmd := &cobra.Command{
		Use:   "status",
		Short: "Get server status",
		Annotations: GetDescriptions([]string{
			"This command gets the status of the server.",
			"This command checks if the server is running and returns its status.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			// Get server status logic
		},
	}
	return statusCmd
}

func startServer() *cobra.Command {
	startCmd := &cobra.Command{
		Use:   "start",
		Short: "Start the server",
		Annotations: GetDescriptions([]string{
			"This command starts the server.",
			"This command initializes the server and starts waiting for help to build prompts.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			// Start server logic
		},
	}
	return startCmd
}

func main() {
	// load config
	b, err := os.ReadFile("config/sanitize.yaml")
	if err != nil {
		log.Printf("using example config: %v", err)
		b, _ = os.ReadFile("config/sanitize.yaml.example")
	}

	var cfg cfgRoot
	if err := yaml.Unmarshal(b, &cfg); err != nil {
		log.Fatal(err)
	}

	if cfg.Server.Addr == "" {
		cfg.Server.Addr = ":8088"
	}

	// build github client
	ctx := context.Background()
	var ghc *github.Client
	switch strings.ToLower(cfg.GitHub.Auth.Kind) {
	case "pat":
		ghc, err = githubx.NewPAT(ctx, githubx.PATConfig{
			Token:     os.ExpandEnv(cfg.GitHub.Auth.Token),
			BaseURL:   cfg.GitHub.Auth.BaseURL,
			UploadURL: cfg.GitHub.Auth.UploadURL,
		})
	case "app":
		ghc, err = githubx.NewApp(ctx, githubx.AppConfig{
			AppID:          cfg.GitHub.Auth.AppID,
			InstallationID: cfg.GitHub.Auth.InstallationID,
			PrivateKeyPath: cfg.GitHub.Auth.PrivateKeyPath,
			BaseURL:        cfg.GitHub.Auth.BaseURL,
			UploadURL:      cfg.GitHub.Auth.UploadURL,
		})
	default:
		err = errors.New("github.auth.kind must be pat|app")
	}

	if err != nil {
		log.Fatal(err)
	}

	// notifiers
	var notifiers []sanitize.Notifier
	for _, n := range cfg.Notifiers {
		switch n.Type {
		case "discord":
			notifiers = append(notifiers, notify.Discord{Webhook: os.ExpandEnv(n.Webhook)})
		case "stdout":
			notifiers = append(notifiers, notify.Stdout{})
		}
	}

	// service
	svc := sanitize.New(ghc, sanitize.Config{
		Runtime: struct {
			DryRun    bool   "yaml:\"dry_run\""
			ReportDir string "yaml:\"report_dir\""
		}{DryRun: cfg.Runtime.DryRun, ReportDir: cfg.Runtime.ReportDir},
		GitHub: struct {
			Repos []sanitize.RepoCfg "yaml:\"repos\""
		}{Repos: cfg.GitHub.Repos},
	}, notifiers...)

	// route: POST /admin/repos/{owner}/{repo}/sanitize?dry_run=1
	http.HandleFunc("/admin/repos/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "only POST", http.StatusMethodNotAllowed)
			return
		}
		// naive parse
		parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/admin/repos/"), "/")
		if len(parts) < 3 || parts[2] != "sanitize" {
			http.NotFound(w, r)
			return
		}
		owner, repo := parts[0], parts[1]
		dry := r.URL.Query().Get("dry_run")
		dryRun := dry == "1" || strings.EqualFold(dry, "true")

		// find rules (optional override via cfg)
		var rules sanitize.Rules
		for _, rc := range cfg.GitHub.Repos {
			if rc.Owner == owner && rc.Name == repo {
				rules = rc.Rules
				break
			}
		}

		var dummy sanitize.Rules
		dummy.Runs.MaxAgeDays = 30
		dummy.Artifacts.MaxAgeDays = 7
		dummy.Releases.DeleteDrafts = true

		if rules.Artifacts == dummy.Artifacts &&
			rules.Runs.MaxAgeDays == dummy.Runs.MaxAgeDays &&
			rules.Releases == dummy.Releases {
			// default sane rules
			rules.Runs.MaxAgeDays = 30
			rules.Artifacts.MaxAgeDays = 7
			rules.Releases.DeleteDrafts = true
		}

		rpt, err := svc.SanitizeRepo(r.Context(), owner, repo, rules, dryRun)
		if err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		_ = json.NewEncoder(w).Encode(rpt)
	})

	srv := &http.Server{
		Addr:              cfg.Server.Addr,
		ReadHeaderTimeout: 5 * time.Second,
	}

	log.Printf("listening on %s", cfg.Server.Addr)
	log.Fatal(srv.ListenAndServe())
}

/// cmd/main.go ///
package main

import (
	"github.com/rafa-mori/ghbex/internal/module"
	gl "github.com/rafa-mori/ghbex/internal/module/logger"
)

// This file is the entry point for the Ghbex CLI application.
// It initializes the logger and starts the application by executing the main command.
// It allows the application to be run as a standalone CLI tool.

// main initializes the logger and creates a new Ghbex instance.
func main() {
	if err := module.RegX().Command().Execute(); err != nil {
		gl.Log("fatal", err.Error())
	}
}

/// config/sanitize.yaml ///
runtime:
  dry_run: true
  report_dir: ./_reports

server:
  addr: ":8088"

github:
  auth:
    kind: "pat" # "pat" | "app"
    token: "${GITHUB_TOKEN}" # se kind=pat
    app_id: 0 # se kind=app
    installation_id: 0 # se kind=app
    private_key_path: "./secrets/gh_app.pem"
    base_url: "" # GHES: https://ghe.example/api/v3/
    upload_url: "" # GHES: https://ghe.example/api/uploads/
  repos:
    - owner: "rafa-mori"
      name: "grompt"
      rules:
        runs:
          max_age_days: 30
          keep_success_last: 10
          only_workflows: [] # ["build.yml","release.yml"]
        artifacts:
          max_age_days: 7
        releases:
          delete_drafts: true

notifiers:
  - type: "stdout"
  - type: "discord"
    webhook: "${DISCORD_WEBHOOK_URL}"

/// docs/README.md ///
# MCP Repo Sanitizer (Go + google/go-github)

MVP para higienizar repositórios GitHub:

- **Autenticação**: PAT *ou* GitHub App (JWT + Installation Token) — sem libs externas.
- **Ações**: apagar **workflow runs** antigos, **artifacts** velhos, **releases** em **draft**.
- **HTTP**: `POST /admin/repos/{owner}/{repo}/sanitize?dry_run=true`
- **Reports**: salva `.json` e `.md` em `_reports/YYYY-MM-DD/`.
- **Discord**: envia resumo via webhook.

> Pensado para encaixar no seu BE atual. Se já tiver API Gateway/Router, só “wirear” o `Service` e o `Client`.

## Uso rápido

```bash
# deps
go mod tidy

# configure
cp config/sanitize.yaml.example config/sanitize.yaml
# set DISCORD_WEBHOOK_URL se quiser notificação

# run
go run ./cmd/server

# testar (dry-run)
curl -X POST "http://localhost:8088/admin/repos/rafa-mori/grompt/sanitize?dry_run=true" | jq
````

## Estrutura

- `internal/githubx`: client GitHub (PAT/App), sem `ghinstallation`.
- `internal/sanitize`: regras e execução (runs/artifacts/releases).
- `internal/notify`: Discord notifier simples.
- `cmd/server`: HTTP mínimo pra você colar no seu gateway depois.

## Notas

- Para **GitHub App**, coloque o `.pem` no caminho do `config`.
- Para **GHES**, configure `base_url`/`upload_url` (ex.: `https://ghe.example/api/v3/`).
- **Dry-run** por padrão no YAML. Só desligue quando estiver confortável.

---

/// internal/githubx/appjwt.go ///
package githubx

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

func makeAppJWT(priv *rsa.PrivateKey, appID int64, dur time.Duration) (string, error) {
	now := time.Now()
	iat := now.Add(-30 * time.Second).Unix()
	exp := now.Add(dur).Unix()

	header := map[string]any{"alg": "RS256", "typ": "JWT"}
	payload := map[string]any{"iat": iat, "exp": exp, "iss": fmt.Sprintf("%d", appID)}

	hb, _ := json.Marshal(header)
	pb, _ := json.Marshal(payload)

	enc := func(b []byte) string { return base64.RawURLEncoding.EncodeToString(b) }

	unsigned := enc(hb) + "." + enc(pb)
	sig, err := rsa.SignPKCS1v15(rand.Reader, priv, crypto.SHA256, sha256Bytes(unsigned))
	if err != nil {
		return "", err
	}
	return unsigned + "." + enc(sig), nil
}

func sha256Bytes(s string) []byte {
	h := crypto.SHA256.New()
	h.Write([]byte(s))
	return h.Sum(nil)
}

func createInstallationToken(hc *http.Client, base string, instID int64, jwt string) (token string, expiry time.Time, err error) {
	url := fmt.Sprintf("%s/app/installations/%d/access_tokens", base, instID)
	req, _ := http.NewRequest("POST", url, bytes.NewReader([]byte("{}")))
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Authorization", "Bearer "+jwt)
	resp, err := hc.Do(req)
	if err != nil {
		return "", time.Time{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode/100 != 2 {
		return "", time.Time{}, fmt.Errorf("installation token http %d", resp.StatusCode)
	}
	var out struct {
		Token     string    `json:"token"`
		ExpiresAt time.Time `json:"expires_at"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&out); err != nil {
		return "", time.Time{}, err
	}
	return out.Token, out.ExpiresAt, nil
}

/// internal/githubx/client.go ///
// Package githubx provides a GitHub client with support for both PAT and App authentication.
package githubx

import (
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/google/go-github/v61/github"
	"golang.org/x/oauth2"
)

// -------- PAT --------

type PATConfig struct {
	Token     string
	BaseURL   string
	UploadURL string
}

func NewPAT(ctx context.Context, cfg PATConfig) (*github.Client, error) {
	if strings.TrimSpace(cfg.Token) == "" {
		return nil, errors.New("missing PAT token")
	}
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: cfg.Token})
	hc := oauth2.NewClient(ctx, ts)
	if cfg.BaseURL != "" {
		upload := cfg.UploadURL
		if upload == "" {
			upload = strings.Replace(cfg.BaseURL, "/api/v3/", "/api/uploads/", 1)
		}
		return github.NewEnterpriseClient(cfg.BaseURL, upload, hc)
	}
	return github.NewClient(hc), nil
}

// -------- GitHub App (sem ghinstallation) --------

type AppConfig struct {
	AppID          int64
	InstallationID int64
	PrivateKeyPath string
	BaseURL        string
	UploadURL      string
}

func NewApp(ctx context.Context, cfg AppConfig) (*github.Client, error) {
	if cfg.AppID == 0 || cfg.InstallationID == 0 || cfg.PrivateKeyPath == "" {
		return nil, errors.New("missing GitHub App config")
	}
	keyPEM, err := os.ReadFile(cfg.PrivateKeyPath)
	if err != nil {
		return nil, err
	}
	priv, err := parseRSAPrivateKeyFromPEM(keyPEM)
	if err != nil {
		return nil, fmt.Errorf("invalid app private key: %w", err)
	}

	baseAPI := cfg.BaseURL
	if baseAPI == "" {
		baseAPI = "https://api.github.com/"
	}
	tokenSrc := &installationTokenSource{
		appID:          cfg.AppID,
		installationID: cfg.InstallationID,
		privateKey:     priv,
		apiBase:        strings.TrimRight(baseAPI, "/"),
		client:         http.DefaultClient,
	}

	hc := oauth2.NewClient(ctx, tokenSrc)
	if cfg.BaseURL != "" {
		upload := cfg.UploadURL
		if upload == "" {
			upload = strings.Replace(cfg.BaseURL, "/api/v3/", "/api/uploads/", 1)
		}
		return github.NewEnterpriseClient(cfg.BaseURL, upload, hc)
	}
	return github.NewClient(hc), nil

}

// installationTokenSource gera e renova tokens de instalação sob demanda.
type installationTokenSource struct {
	appID          int64
	installationID int64
	privateKey     *rsa.PrivateKey
	apiBase        string
	client         *http.Client

	mu    sync.Mutex
	token *oauth2.Token
}

func (s *installationTokenSource) Token() (*oauth2.Token, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	// ainda válido?
	if s.token != nil && s.token.Expiry.After(time.Now().Add(30*time.Second)) {
		return s.token, nil
	}

	// gera JWT do App
	jwt, err := makeAppJWT(s.privateKey, s.appID, 9*time.Minute)
	if err != nil {
		return nil, err
	}

	// troca por installation token
	tok, exp, err := createInstallationToken(s.client, s.apiBase, s.installationID, jwt)
	if err != nil {
		return nil, err
	}
	s.token = &oauth2.Token{
		AccessToken: tok,
		TokenType:   "token",
		Expiry:      exp,
	}
	return s.token, nil

}

func parseRSAPrivateKeyFromPEM(pemBytes []byte) (*rsa.PrivateKey, error) {
	block, _ := pem.Decode(pemBytes)
	if block == nil {
		return nil, errors.New("no PEM block found")
	}
	switch block.Type {
	case "RSA PRIVATE KEY":
		return x509.ParsePKCS1PrivateKey(block.Bytes)
	case "PRIVATE KEY":
		k, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		if err != nil {
			return nil, err
		}
		rsaKey, ok := k.(*rsa.PrivateKey)
		if !ok {
			return nil, errors.New("not RSA key")
		}
		return rsaKey, nil
	default:
		return nil, errors.New("unsupported PEM type: " + block.Type)
	}
}

/// internal/module/info/application.go ///
// Package manifest provides functionality to read and parse the application manifest.
package manifest

import (
	_ "embed"
	"encoding/json"

	l "github.com/rafa-mori/logz"
)

//go:embed manifest.json
var manifestJSONData []byte
var application Manifest

type manifest struct {
	Manifest
	Name            string   `json:"name"`
	ApplicationName string   `json:"application"`
	Bin             string   `json:"bin"`
	Version         string   `json:"version"`
	Repository      string   `json:"repository"`
	Aliases         []string `json:"aliases,omitempty"`
	Homepage        string   `json:"homepage,omitempty"`
	Description     string   `json:"description,omitempty"`
	Main            string   `json:"main,omitempty"`
	Author          string   `json:"author,omitempty"`
	License         string   `json:"license,omitempty"`
	Keywords        []string `json:"keywords,omitempty"`
	Platforms       []string `json:"platforms,omitempty"`
	LogLevel        string   `json:"log_level,omitempty"`
	Debug           bool     `json:"debug,omitempty"`
	ShowTrace       bool     `json:"show_trace,omitempty"`
	Private         bool     `json:"private,omitempty"`
}
type Manifest interface {
	GetName() string
	GetVersion() string
	GetAliases() []string
	GetRepository() string
	GetHomepage() string
	GetDescription() string
	GetMain() string
	GetBin() string
	GetAuthor() string
	GetLicense() string
	GetKeywords() []string
	GetPlatforms() []string
	IsPrivate() bool
}

func (m *manifest) GetName() string        { return m.Name }
func (m *manifest) GetVersion() string     { return m.Version }
func (m *manifest) GetAliases() []string   { return m.Aliases }
func (m *manifest) GetRepository() string  { return m.Repository }
func (m *manifest) GetHomepage() string    { return m.Homepage }
func (m *manifest) GetDescription() string { return m.Description }
func (m *manifest) GetMain() string        { return m.Main }
func (m *manifest) GetBin() string         { return m.Bin }
func (m *manifest) GetAuthor() string      { return m.Author }
func (m *manifest) GetLicense() string     { return m.License }
func (m *manifest) GetKeywords() []string  { return m.Keywords }
func (m *manifest) GetPlatforms() []string { return m.Platforms }
func (m *manifest) IsPrivate() bool        { return m.Private }

func init() {
	_, err := GetManifest()
	if err != nil {
		l.GetLogger("Kubex")
		l.Fatal("Failed to get manifest: " + err.Error())
	}
}

func GetManifest() (Manifest, error) {
	if application != nil {
		return application, nil
	}

	var m manifest
	if err := json.Unmarshal(manifestJSONData, &m); err != nil {
		return nil, err
	}

	application = &m
	return application, nil
}

/// internal/module/info/manifest.json ///
{
  "name": "Kubex - Grompt",
  "application": "grompt",
  "version": "1.2.0",
  "private": false,
  "published": true,
  "aliases": [
    "grompt",
    "krompt"
  ],
  "repository": "https://github.com/rafa-mori/grompt",
  "homepage": "https://grompt.rafa-mori.dev/",
  "description": "Kubex - Grompt is a profissional AI prompt context object kind like: agents, prompts, API calls, and more.",
  "main": "cmd/main.go",
  "bin": "grompt",
  "author": "Rafael Mori <faelmori@gmail.com>",
  "organization": "rafa-mori",
  "license": "MIT",
  "keywords": [
    "grompt",
    "kubex",
    "file-markers",
    "control",
    "command-line",
    "tool",
    "management"
  ],
  "platforms": [
    "linux/amd64"
  ],
  "dependencies": [
    "tar",
    "gzip",
    "curl",
    "git",
    "zip",
    "unzip",
    "jq",
    "upx"
  ]
}

/// internal/module/logger/logger.go ///
// Package logger provides a logging utility for Go applications.
package logger

import (
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strings"
	"time"

	manifest "github.com/rafa-mori/ghbex/internal/module/info"
	l "github.com/rafa-mori/logz"
)

type GLog[T any] interface {
	GetLogger() l.Logger
	GetLogLevel() LogLevel
	GetShowTrace() bool
	GetDebug() bool
	SetLogLevel(string)
	SetDebug(bool)
	SetShowTrace(bool)
	ObjLog(*T, string, ...any)
	Log(string, ...any)
}

type gLog[T any] struct {
	l.Logger
	gLogLevel  LogLevel // Global log level
	gShowTrace bool     // Flag to show trace in logs
	gDebug     bool     // Flag to show debug messages
}

type LogType string
type LogLevel int

var (
	info      manifest.Manifest
	debug     bool
	showTrace bool
	logLevel  string
	g         *gLog[l.Logger] // Global logger instance
	Logger    GLog[l.Logger]
	err       error
)

const (
	// LogTypeDebug is the log type for debug messages.
	LogTypeDebug LogType = "debug"
	// LogTypeNotice is the log type for notice messages.
	LogTypeNotice LogType = "notice"
	// LogTypeInfo is the log type for informational messages.
	LogTypeInfo LogType = "info"
	// LogTypeWarn is the log type for warning messages.
	LogTypeWarn LogType = "warn"
	// LogTypeError is the log type for error messages.
	LogTypeError LogType = "error"
	// LogTypeFatal is the log type for fatal error messages.
	LogTypeFatal LogType = "fatal"
	// LogTypePanic is the log type for panic messages.
	LogTypePanic LogType = "panic"
	// LogTypeSuccess is the log type for success messages.
	LogTypeSuccess LogType = "success"
)

const (
	// LogLevelDebug 0
	LogLevelDebug LogLevel = iota
	// LogLevelNotice 1
	LogLevelNotice
	// LogLevelInfo 2
	LogLevelInfo
	// LogLevelSuccess 3
	LogLevelSuccess
	// LogLevelWarn 4
	LogLevelWarn
	// LogLevelError 5
	LogLevelError
	// LogLevelFatal 6
	LogLevelFatal
	// LogLevelPanic 7
	LogLevelPanic
)

func getEnvOrDefault[T string | int | bool](key string, defaultValue T) T {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	} else {
		valInterface := reflect.ValueOf(value)
		if valInterface.Type().ConvertibleTo(reflect.TypeFor[T]()) {
			return valInterface.Convert(reflect.TypeFor[T]()).Interface().(T)
		}
	}
	return defaultValue
}

func init() {
	if info == nil {
		info, err = manifest.GetManifest()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get info manifest: %v\n", err)
			os.Exit(1)
		}
		l.GetLogger(info.GetBin())
	}
	if Logger == nil {
		Logger = GetLogger[l.Logger](nil)
		if logger, ok := Logger.(*gLog[l.Logger]); ok {
			g = logger
			logLevel = getEnvOrDefault("GOBE_LOG_LEVEL", "error")
			debug = getEnvOrDefault("GOBE_DEBUG", false)
			showTrace = getEnvOrDefault("GOBE_SHOW_TRACE", false)
			//g.gLogLevel = LogLevelError
			g.gLogLevel = LogLevelInfo
			g.gShowTrace = showTrace
			g.gDebug = debug
		}
	}
}

func setLogLevel(logLevel string) {
	if g == nil || Logger == nil {
		_ = GetLogger[l.Logger](nil)
	}
	switch strings.ToLower(logLevel) {
	case "debug":
		g.gLogLevel = LogLevelDebug
		g.SetLevel("debug")
	case "info":
		g.gLogLevel = LogLevelInfo
		g.SetLevel("info")
	case "warn":
		g.gLogLevel = LogLevelWarn
		g.SetLevel("warn")
	case "error":
		g.gLogLevel = LogLevelError
		g.SetLevel("error")
	case "fatal":
		g.gLogLevel = LogLevelFatal
		g.SetLevel("fatal")
	case "panic":
		g.gLogLevel = LogLevelPanic
		g.SetLevel("panic")
	case "notice":
		g.gLogLevel = LogLevelNotice
		g.SetLevel("notice")
	case "success":
		g.gLogLevel = LogLevelSuccess
		g.SetLevel("success")
	default:
		// logLevel = "error"
		// g.gLogLevel = LogLevelError
		logLevel = "info"
		g.gLogLevel = LogLevelInfo
		g.SetLevel(logLevel)
	}
}
func getShowTrace() bool {
	if debug {
		return true
	} else {
		if !showTrace {
			return false
		} else {
			return true
		}
	}
}
func willPrintLog(logType string) bool {
	if debug {
		return true
	} else {
		lTypeInt := LogLevelError
		switch strings.ToLower(logType) {
		case "debug":
			lTypeInt = LogLevelDebug
		case "info":
			lTypeInt = LogLevelInfo
		case "warn":
			lTypeInt = LogLevelWarn
		case "error":
			lTypeInt = LogLevelError
		case "notice":
			lTypeInt = LogLevelNotice
		case "success":
			lTypeInt = LogLevelSuccess
		case "fatal":
			lTypeInt = LogLevelFatal
		case "panic":
			lTypeInt = LogLevelPanic
		default:
			lTypeInt = LogLevelError
		}
		return lTypeInt >= g.gLogLevel
	}
}
func getCtxMessageMap(logType, funcName, file string, line int) map[string]any {
	ctxMessageMap := map[string]any{
		"context":   funcName,
		"file":      file,
		"line":      line,
		"logType":   logType,
		"timestamp": time.Now().Format(time.RFC3339),
		"version":   info.GetVersion(),
	}
	if !debug && !showTrace {
		ctxMessageMap["showData"] = false
	} else {
		ctxMessageMap["showData"] = getShowTrace()
	}
	if info != nil {
		ctxMessageMap["appName"] = info.GetName()
		ctxMessageMap["bin"] = info.GetBin()
		ctxMessageMap["version"] = info.GetVersion()
	}
	return ctxMessageMap
}
func getFuncNameMessage(lgr l.Logger) (string, int, string) {
	if lgr == nil {
		return "", 0, ""
	}
	if getShowTrace() {
		pc, file, line, ok := runtime.Caller(3)
		if !ok {
			lgr.ErrorCtx("Log: unable to get caller information", nil)
			return "", 0, ""
		}
		funcName := runtime.FuncForPC(pc).Name()
		if strings.Contains(funcName, "LogObjLogger") {
			pc, file, line, ok = runtime.Caller(4)
			if !ok {
				lgr.ErrorCtx("Log: unable to get caller information", nil)
				return "", 0, ""
			}
			funcName = runtime.FuncForPC(pc).Name()
		}
		return funcName, line, file
	}
	return "", 0, ""
}
func getFullMessage(messages ...any) string {
	fullMessage := ""
	for _, msg := range messages {
		if msg != nil {
			if str, ok := msg.(string); ok {
				fullMessage += str + " "
			} else {
				fullMessage += fmt.Sprintf("%v ", msg)
			}
		}
	}
	return strings.TrimSpace(fullMessage)
}

func SetDebug(d bool) {
	if g == nil || Logger == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.gDebug = d
	if d {
		g.SetLevel("debug")
	} else {
		switch g.gLogLevel {
		case LogLevelDebug:
			g.SetLevel("debug")
		case LogLevelInfo:
			g.SetLevel("info")
		case LogLevelWarn:
			g.SetLevel("warn")
		case LogLevelError:
			g.SetLevel("error")
		case LogLevelFatal:
			g.SetLevel("fatal")
		case LogLevelPanic:
			g.SetLevel("panic")
		case LogLevelNotice:
			g.SetLevel("notice")
		case LogLevelSuccess:
			g.SetLevel("success")
		default:
			g.SetLevel("info")
		}
	}
}
func GetLogger[T any](obj *T) GLog[l.Logger] {
	if g == nil || Logger == nil {
		g = &gLog[l.Logger]{
			Logger:     l.GetLogger(info.GetBin()),
			gLogLevel:  LogLevelInfo,
			gShowTrace: showTrace,
			gDebug:     debug,
		}
		Logger = g
	}
	if obj == nil {
		return Logger
	}
	var lgr l.Logger
	if objValueLogger := reflect.ValueOf(obj).Elem().MethodByName("GetLogger"); !objValueLogger.IsValid() {
		if objValueLogger = reflect.ValueOf(obj).Elem().FieldByName("Logger"); !objValueLogger.IsValid() {
			g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
				"context":  "Log",
				"logType":  "error",
				"object":   obj,
				"msg":      "object does not have a logger field",
				"showData": getShowTrace(),
			})
			return g
		} else {
			lgrC := objValueLogger.Convert(reflect.TypeFor[l.Logger]())
			if lgrC.IsNil() {
				lgrC = reflect.ValueOf(g.Logger)
			}
			if lgr = lgrC.Interface().(l.Logger); lgr == nil {
				lgr = g.Logger
			}
		}
	} else {
		lgr = g
	}
	if lgr == nil {
		g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
			"context":  "Log",
			"logType":  "error",
			"object":   obj,
			"msg":      "object does not have a logger field",
			"showData": getShowTrace(),
		})
		return Logger
	}
	return &gLog[l.Logger]{
		Logger:     lgr,
		gLogLevel:  g.gLogLevel,
		gShowTrace: g.gShowTrace,
		gDebug:     g.gDebug,
	}
}
func LogObjLogger[T any](obj *T, logType string, messages ...any) {
	lgr := GetLogger(obj)
	if lgr == nil {
		g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
			"context":  "Log",
			"logType":  logType,
			"object":   obj,
			"msg":      messages,
			"showData": getShowTrace(),
		})
		return
	}

	fullMessage := getFullMessage(messages...)
	logType = strings.ToLower(logType)
	funcName, line, file := getFuncNameMessage(lgr.GetLogger())

	ctxMessageMap := getCtxMessageMap(logType, funcName, file, line)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			logging(lgr.GetLogger(), lType, fullMessage, ctxMessageMap)
		} else {
			lgr.GetLogger().ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		lgr.GetLogger().InfoCtx(fullMessage, ctxMessageMap)
	}
}
func Log(logType string, messages ...any) {
	funcName, line, file := getFuncNameMessage(g.Logger)
	fullMessage := getFullMessage(messages...)
	logType = strings.ToLower(logType)
	ctxMessageMap := getCtxMessageMap(logType, funcName, file, line)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			ctxMessageMap["logType"] = logType
			logging(g.Logger, lType, fullMessage, ctxMessageMap)
		} else {
			g.ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		logging(g.Logger, LogTypeInfo, fullMessage, ctxMessageMap)
	}
}
func logging(lgr l.Logger, lType LogType, fullMessage string, ctxMessageMap map[string]any) {
	lt := strings.ToLower(string(lType))
	if _, exist := ctxMessageMap["showData"]; !exist {
		ctxMessageMap["showData"] = getShowTrace()
	}
	if willPrintLog(lt) {
		switch lType {
		case LogTypeInfo:
			lgr.InfoCtx(fullMessage, ctxMessageMap)
		case LogTypeDebug:
			lgr.DebugCtx(fullMessage, ctxMessageMap)
		case LogTypeError:
			lgr.ErrorCtx(fullMessage, ctxMessageMap)
		case LogTypeWarn:
			lgr.WarnCtx(fullMessage, ctxMessageMap)
		case LogTypeNotice:
			lgr.NoticeCtx(fullMessage, ctxMessageMap)
		case LogTypeSuccess:
			lgr.SuccessCtx(fullMessage, ctxMessageMap)
		case LogTypeFatal:
			lgr.FatalCtx(fullMessage, ctxMessageMap)
		case LogTypePanic:
			lgr.FatalCtx(fullMessage, ctxMessageMap)
		default:
			lgr.InfoCtx(fullMessage, ctxMessageMap)
		}
	} else {
		ctxMessageMap["msg"] = fullMessage
		ctxMessageMap["showData"] = false
		lgr.DebugCtx("Log: message not printed due to log level", ctxMessageMap)
	}
}

func (g *gLog[T]) GetLogger() l.Logger                 { return g.Logger }
func (g *gLog[T]) GetLogLevel() LogLevel               { return g.gLogLevel }
func (g *gLog[T]) GetShowTrace() bool                  { return g.gShowTrace }
func (g *gLog[T]) GetDebug() bool                      { return g.gDebug }
func (g *gLog[T]) SetLogLevel(logLevel string)         { setLogLevel(logLevel) }
func (g *gLog[T]) SetShowTrace(showTrace bool)         { g.gShowTrace = showTrace }
func (g *gLog[T]) SetDebug(d bool)                     { SetDebug(d); g.gDebug = d }
func (g *gLog[T]) Log(logType string, messages ...any) { Log(logType, messages...) }
func (g *gLog[T]) ObjLog(obj *T, logType string, messages ...any) {
	LogObjLogger(obj, logType, messages...)
}

func (g *gLog[T]) Notice(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("notice", m...)
}
func (g *gLog[T]) Info(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("info", m...)
}
func (g *gLog[T]) Debug(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("debug", m...)
}
func (g *gLog[T]) Warn(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("warn", m...)
}
func (g *gLog[T]) Error(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("error", m...)
}
func (g *gLog[T]) Fatal(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("fatal", m...)
}
func (g *gLog[T]) Panic(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("fatal", m...)
}
func (g *gLog[T]) Success(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("success", m...)
}

func NewLogger[T any](prefix string) GLog[T] {
	return &gLog[T]{
		Logger:     l.NewLogger(prefix),
		gLogLevel:  LogLevelError,
		gShowTrace: false,
		gDebug:     false,
	}
}

/// internal/module/module.go ///
// Package module provides internal types and functions for the Ghbex application.
package module

import (
	cc "github.com/rafa-mori/ghbex/cmd/cli"
	gl "github.com/rafa-mori/ghbex/internal/module/logger"
	vs "github.com/rafa-mori/ghbex/internal/module/version"
	"github.com/spf13/cobra"

	"os"
	"strings"
)

type Ghbex struct {
	parentCmdName string
	PrintBanner   bool
}

func (m *Ghbex) Alias() string {
	return ""
}
func (m *Ghbex) ShortDescription() string {
	return "Ghbex a tool for building prompts with AI assistance."
}
func (m *Ghbex) LongDescription() string {
	return `Ghbex: A tool for building prompts with AI assistance using real engineering practices. Better prompts, better results.., Awesome prompts, AMAZING results !!!`
}
func (m *Ghbex) Usage() string {
	return "ghbex [command] [args]"
}
func (m *Ghbex) Examples() []string {
	return []string{
		"ghbex start",
		"ghbex stop",
		"ghbex status",
	}
}
func (m *Ghbex) Active() bool {
	return true
}
func (m *Ghbex) Module() string {
	return "ghbex"
}
func (m *Ghbex) Execute() error {
	return m.Command().Execute()
}
func (m *Ghbex) Command() *cobra.Command {
	gl.Log("debug", "Starting Ghbex CLI...")

	var rtCmd = &cobra.Command{
		Use:     m.Module(),
		Aliases: []string{m.Alias()},
		Example: m.concatenateExamples(),
		Version: vs.GetVersion(),
		Annotations: cc.GetDescriptions([]string{
			m.LongDescription(),
			m.ShortDescription(),
		}, m.PrintBanner),
	}

	rtCmd.AddCommand(cc.ServerCmdList()...)
	rtCmd.AddCommand(vs.CliCommand())

	// Set usage definitions for the command and its subcommands
	setUsageDefinition(rtCmd)
	for _, c := range rtCmd.Commands() {
		setUsageDefinition(c)
		if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
			if c.Short == "" {
				c.Short = c.Annotations["description"]
			}
		}
	}

	return rtCmd
}
func (m *Ghbex) SetParentCmdName(rtCmd string) {
	m.parentCmdName = rtCmd
}
func (m *Ghbex) concatenateExamples() string {
	examples := ""
	rtCmd := m.parentCmdName
	if rtCmd != "" {
		rtCmd = rtCmd + " "
	}
	for _, example := range m.Examples() {
		examples += rtCmd + example + "\n  "
	}
	return examples
}

/// internal/module/usage.go ///
package module

import (
	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

// colorYellow, colorGreen, colorBlue, colorRed, and colorHelp are utility functions
// that return a string formatted with the specified color using the fatih/color package.
// These functions are used to colorize output in the CLI usage template.
// They are registered as template functions in the CLI usage template to allow
// coloring specific parts of the command usage output.
func colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}

func colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}

func colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}

func colorRed(s string) string {
	return color.New(color.FgRed).SprintFunc()(s)
}

func colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}

func hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}

func hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}

func setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", colorYellow)
	cobra.AddTemplateFunc("colorGreen", colorGreen)
	cobra.AddTemplateFunc("colorRed", colorRed)
	cobra.AddTemplateFunc("colorBlue", colorBlue)
	cobra.AddTemplateFunc("colorHelp", colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(cliUsageTemplate)
}

var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`

/// internal/module/version/semantic.go ///
// Package version provides functionality to manage and check the version of the Kubex Horizon CLI tool.
// It includes methods to retrieve the current version, check for the latest version,
package version

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	manifest "github.com/rafa-mori/ghbex/internal/module/info"
	"github.com/rafa-mori/ghbex/internal/module/logger"
	"github.com/spf13/cobra"
)

var gl = logger.GetLogger[ServiceImpl](nil)
var (
	info manifest.Manifest
	vrs  Service
	err  error
)

func init() {
	if info == nil {
		info, err = manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
}

type Service interface {
	// GetLatestVersion retrieves the latest version from the Git repository.
	GetLatestVersion() (string, error)
	// GetCurrentVersion returns the current version of the service.
	GetCurrentVersion() string
	// IsLatestVersion checks if the current version is the latest version.
	IsLatestVersion() (bool, error)
	// GetName returns the name of the service.
	GetName() string
	// GetVersion returns the current version of the service.
	GetVersion() string
	// GetRepository returns the Git repository URL of the service.
	GetRepository() string
	// setLastCheckedAt sets the last checked time for the version.
	setLastCheckedAt(time.Time)
	// updateLatestVersion updates the latest version from the Git repository.
	updateLatestVersion() error
}
type ServiceImpl struct {
	manifest.Manifest
	gitModelURL    string
	latestVersion  string
	lastCheckedAt  time.Time
	currentVersion string
}

func init() {
	if info == nil {
		var err error
		info, err = manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
	if vrs == nil {
		vrs = NewVersionService()
	}
}

func getLatestTag(repoURL string) (string, error) {
	defer func() {
		if rec := recover(); rec != nil {
			gl.Log("error", "Recovered from panic in getLatestTag: %v", rec)
			err = fmt.Errorf("panic occurred while fetching latest tag: %v", rec)
		}
	}()

	defer func() {
		if vrs == nil {
			vrs = NewVersionService()
		}
		vrs.setLastCheckedAt(time.Now())
	}()

	if info == nil {
		var err error
		info, err = manifest.GetManifest()
		if err != nil {
			return "", fmt.Errorf("failed to get manifest: %w", err)
		}
	}
	if info.IsPrivate() {
		return "", fmt.Errorf("cannot fetch latest tag for private repositories")
	}

	if repoURL == "" {
		repoURL = info.GetRepository()
		if repoURL == "" {
			return "", fmt.Errorf("repository URL is not set")
		}
	}

	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch tags: %s", resp.Status)
	}
	type Tag struct {
		Name string `json:"name"`
	}

	// Decode the JSON response into a slice of Tag structs
	// This assumes the API returns a JSON array of tags.
	// Adjust the decoding logic based on the actual API response structure.
	if resp.Header.Get("Content-Type") != "application/json" {
		return "", fmt.Errorf("expected application/json, got %s", resp.Header.Get("Content-Type"))
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", fmt.Errorf("no tags found")
	}
	return tags[0].Name, nil
}
func (v *ServiceImpl) updateLatestVersion() error {
	if info.IsPrivate() {
		return fmt.Errorf("cannot fetch latest version for private repositories")
	}
	repoURL := strings.TrimSuffix(v.gitModelURL, ".git")
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	compare := 0
	for i := 0; i < len(v1) && i < len(v2); i++ {
		if v1[i] < v2[i] {
			compare = -1
			break
		}
		if v1[i] > v2[i] {
			compare = 1
			break
		}
	}
	return compare, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	if versionToParse == "" {
		return nil
	}
	if strings.Contains(versionToParse, "-") {
		versionToParse = strings.Split(versionToParse, "-")[0]
	}
	if strings.Contains(versionToParse, "v") {
		versionToParse = strings.TrimPrefix(versionToParse, "v")
	}
	parts := strings.Split(versionToParse, ".")
	parsedVersion := make([]int, len(parts))
	for i, part := range parts {
		if num, err := strconv.Atoi(part); err != nil {
			return nil
		} else {
			parsedVersion[i] = num
		}
	}
	return parsedVersion
}
func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if info.IsPrivate() {
		return false, fmt.Errorf("cannot check version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	currentVersionParts := v.parseVersion(v.currentVersion)
	latestVersionParts := v.parseVersion(v.latestVersion)

	if len(currentVersionParts) == 0 || len(latestVersionParts) == 0 {
		return false, fmt.Errorf("invalid version format")
	}

	if len(currentVersionParts) != len(latestVersionParts) {
		return false, fmt.Errorf("version parts length mismatch")
	}

	return v.versionAtMost(currentVersionParts, latestVersionParts)
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if info.IsPrivate() {
		return "", fmt.Errorf("cannot fetch latest version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}
	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string {
	if v.currentVersion == "" {
		v.currentVersion = info.GetVersion()
	}
	return v.currentVersion
}
func (v *ServiceImpl) GetName() string {
	if info == nil {
		return "Unknown Service"
	}
	return info.GetName()
}
func (v *ServiceImpl) GetVersion() string {
	if info == nil {
		return "Unknown version"
	}
	return info.GetVersion()
}
func (v *ServiceImpl) GetRepository() string {
	if info == nil {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func (v *ServiceImpl) setLastCheckedAt(t time.Time) {
	v.lastCheckedAt = t
	gl.Log("debug", "Last checked at: "+t.Format(time.RFC3339))
}

func NewVersionService() Service {
	return &ServiceImpl{
		Manifest:       info,
		gitModelURL:    info.GetRepository(),
		currentVersion: info.GetVersion(),
		latestVersion:  "",
	}
}

var (
	versionCmd   *cobra.Command
	subLatestCmd *cobra.Command
	subCmdCheck  *cobra.Command
	updCmd       *cobra.Command
	getCmd       *cobra.Command
	restartCmd   *cobra.Command
)

func init() {
	if versionCmd == nil {
		versionCmd = &cobra.Command{
			Use:   "version",
			Short: "Print the version number of " + info.GetName(),
			Long:  "Print the version number of " + info.GetName() + " and other related information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("warn", "The information shown may not be accurate for private repositories.")
					gl.Log("info", "Current version: "+GetVersion())
					gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
					return
				}
				GetVersionInfo()
			},
		}
	}
	if subLatestCmd == nil {
		subLatestCmd = &cobra.Command{
			Use:   "latest",
			Short: "Print the latest version number of " + info.GetName(),
			Long:  "Print the latest version number of " + info.GetName() + " from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot fetch latest version for private repositories.")
					return
				}
				GetLatestVersionInfo()
			},
		}
	}
	if subCmdCheck == nil {
		subCmdCheck = &cobra.Command{
			Use:   "check",
			Short: "Check if the current version is the latest version of " + info.GetName(),
			Long:  "Check if the current version is the latest version of " + info.GetName() + " and print the version information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot check version for private repositories.")
					return
				}
				GetVersionInfoWithLatestAndCheck()
			},
		}
	}
	if updCmd == nil {
		updCmd = &cobra.Command{
			Use:   "update",
			Short: "Update the version information of " + info.GetName(),
			Long:  "Update the version information of " + info.GetName() + " by fetching the latest version from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot update version for private repositories.")
					return
				}
				if err := vrs.updateLatestVersion(); err != nil {
					gl.Log("error", "Failed to update version: "+err.Error())
				} else {
					latestVersion, err := vrs.GetLatestVersion()
					if err != nil {
						gl.Log("error", "Failed to get latest version: "+err.Error())
					} else {
						gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
						gl.Log("info", "Latest version: "+latestVersion)
					}
					vrs.setLastCheckedAt(time.Now())
				}
			},
		}
	}
	if getCmd == nil {
		getCmd = &cobra.Command{
			Use:   "get",
			Short: "Get the current version of " + info.GetName(),
			Long:  "Get the current version of " + info.GetName() + " from the manifest.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
			},
		}
	}
	if restartCmd == nil {
		restartCmd = &cobra.Command{
			Use:   "restart",
			Short: "Restart the " + info.GetName() + " service",
			Long:  "Restart the " + info.GetName() + " service to apply any changes made.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Restarting the service...")
				// Logic to restart the service can be added here
				gl.Log("success", "Service restarted successfully")
			},
		}
	}

}
func GetVersion() string {
	if info == nil {
		_, err := manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
			return "Unknown version"
		}
	}
	return info.GetVersion()
}
func GetGitRepositoryModelURL() string {
	if info.GetRepository() == "" {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func GetVersionInfo() string {
	gl.Log("info", "Version: "+GetVersion())
	gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitRepositoryModelURL())
}
func GetLatestVersionFromGit() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}

	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitURLWithoutGit := strings.TrimSuffix(GetGitRepositoryModelURL(), ".git")
	if gitURLWithoutGit == "" {
		gl.Log("error", "No repository URL set in the manifest.")
		return "No repository URL set in the manifest."
	}

	response, err := netClient.Get(gitURLWithoutGit + "/releases/latest")
	if err != nil {
		gl.Log("error", "Error fetching latest version: "+err.Error())
		gl.Log("error", gitURLWithoutGit+"/releases/latest")
		return err.Error()
	}

	if response.StatusCode != 200 {
		gl.Log("error", "Error fetching latest version: "+response.Status)
		gl.Log("error", "Url: "+gitURLWithoutGit+"/releases/latest")
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("Error: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}
func GetLatestVersionInfo() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}
	gl.Log("info", "Latest version: "+GetLatestVersionFromGit())
	return "Latest version: " + GetLatestVersionFromGit()
}
func GetVersionInfoWithLatestAndCheck() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot check version for private repositories.")
		return "Cannot check version for private repositories."
	}
	if GetVersion() == GetLatestVersionFromGit() {
		gl.Log("info", "You are using the latest version.")
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		gl.Log("warn", "You are using an outdated version.")
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}
func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	versionCmd.AddCommand(updCmd)
	versionCmd.AddCommand(getCmd)
	versionCmd.AddCommand(restartCmd)
	return versionCmd
}

/// internal/module/wrpr.go ///
package module

import (
	"os"
	"strings"
)

func RegX() *Ghbex {
	var printBannerV = os.Getenv("GHBEX_PRINT_BANNER")
	if printBannerV == "" {
		printBannerV = "true"
	}

	return &Ghbex{
		PrintBanner: strings.ToLower(printBannerV) == "true",
	}
}

/// internal/notify/discord.go ///
// Package notify provides functionality for sending notifications to various channels.
package notify

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/rafa-mori/ghbex/internal/sanitize"
)

type Discord struct {
	Webhook string
}

type Stdout struct{}

func (Stdout) Send(ctx context.Context, title, text string, files ...sanitize.Attachment) error {
	fmt.Printf("\n==== %s ====\n%s\n", title, text)
	return nil
}

func (d Discord) Send(ctx context.Context, title, text string, files ...sanitize.Attachment) error {
	if d.Webhook == "" {
		return nil
	}
	payload := map[string]any{
		"content": "**" + title + "**\n" + text,
	}
	b, _ := json.Marshal(payload)
	req, _ := http.NewRequestWithContext(ctx, "POST", d.Webhook, bytes.NewReader(b))
	req.Header.Set("Content-Type", "application/json")
	_, err := http.DefaultClient.Do(req)
	return err
}

/// internal/sanitize/gh_cleaners.go ///
package sanitize

import (
	"context"
	"slices"
	"time"

	"github.com/google/go-github/v61/github"
)

func cleanRuns(ctx context.Context, cli *github.Client, owner, repo string, r RunsRule, dry bool) (deleted, kept int, ids []int64, err error) {
	opt := &github.ListWorkflowRunsOptions{ListOptions: github.ListOptions{PerPage: 100}}
	cut := cutoff(r.MaxAgeDays)
	allow := func(name string) bool {
		if len(r.OnlyWorkflows) == 0 {
			return true
		}
		return slices.Contains(r.OnlyWorkflows, name)
	}

	for {
		rs, resp, e := cli.Actions.ListRepositoryWorkflowRuns(ctx, owner, repo, opt)
		if e != nil {
			err = e
			return
		}
		for _, run := range rs.WorkflowRuns {
			if !allow(run.GetName()) {
				continue
			}
			ids = append(ids, run.GetID())

			// keep N latest successful
			if run.GetStatus() == "completed" && run.GetConclusion() == "success" && kept < r.KeepSuccessLast {
				kept++
				continue
			}
			// age filter
			if !cut.IsZero() && run.GetCreatedAt().Time.After(cut) {
				continue
			}
			if dry {
				deleted++
				continue
			}
			if e := deleteRun(ctx, cli, owner, repo, run.GetID()); e == nil {
				deleted++
			}
			if resp.NextPage == 0 {
				break
			}
			opt.Page = resp.NextPage
		}

		return
	}
}

func deleteRun(ctx context.Context, cli *github.Client, owner, repo string, id int64) error {
	_, err := cli.Actions.DeleteWorkflowRun(ctx, owner, repo, id)
	return err
}

func cleanArtifacts(ctx context.Context, cli *github.Client, owner, repo string, r ArtifactsRule, dry bool) (deleted int, ids []int64, err error) {
	cut := cutoff(r.MaxAgeDays)
	opt := &github.ListOptions{PerPage: 100}
	for {
		arts, resp, e := cli.Actions.ListArtifacts(ctx, owner, repo, opt)
		if e != nil {
			err = e
			return
		}
		for _, a := range arts.Artifacts {
			ids = append(ids, a.GetID())
			if cut.IsZero() || a.GetCreatedAt().Time.Before(cut) {
				if dry {
					deleted++
					continue
				}
				if e := deleteArtifact(ctx, cli, owner, repo, a.GetID()); e == nil {
					deleted++
				}
			}
		}
		if resp.NextPage == 0 {
			break
		}
		opt.Page = resp.NextPage
	}
	return
}

func deleteArtifact(ctx context.Context, cli *github.Client, owner, repo string, id int64) error {
	_, err := cli.Actions.DeleteArtifact(ctx, owner, repo, id)
	return err
}

func cleanReleases(ctx context.Context, cli *github.Client, owner, repo string, r ReleasesRule, dry bool) (deletedDrafts int, tags []string, err error) {
	opt := &github.ListOptions{PerPage: 100}
	for {
		rel, resp, e := cli.Repositories.ListReleases(ctx, owner, repo, opt)
		if e != nil {
			err = e
			return
		}
		for _, rr := range rel {
			if rr.GetDraft() && r.DeleteDrafts {
				if dry {
					deletedDrafts++
					continue
				}
				if e := deleteRelease(ctx, cli, owner, repo, rr.GetID()); e == nil {
					deletedDrafts++
				}
			}
			if rr.TagName != nil {
				tags = append(tags, rr.GetTagName())
			}
		}
		if resp.NextPage == 0 {
			break
		}
		opt.Page = resp.NextPage
	}
	return
}

func deleteRelease(ctx context.Context, cli *github.Client, owner, repo string, id int64) error {
	_, err := cli.Repositories.DeleteRelease(ctx, owner, repo, id)
	return err
}

func cutoff(days int) time.Time {
	if days <= 0 {
		return time.Time{}
	}
	return time.Now().AddDate(0, 0, -days)
}

/// internal/sanitize/service.go ///
package sanitize

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/google/go-github/v61/github"
)

type Notifier interface {
	Send(ctx context.Context, title, text string, files ...Attachment) error
}
type Attachment struct {
	Name string
	Body []byte
}

type Service struct {
	cli       *github.Client
	cfg       Config
	notifiers []Notifier
}

func New(cli *github.Client, cfg Config, ntf ...Notifier) *Service {
	return &Service{cli: cli, cfg: cfg, notifiers: ntf}
}

type Report struct {
	Owner  string    `json:"owner"`
	Repo   string    `json:"repo"`
	When   time.Time `json:"when"`
	DryRun bool      `json:"dry_run"`

	Runs struct {
		Deleted int     `json:"deleted"`
		Kept    int     `json:"kept"`
		IDs     []int64 `json:"ids"`
	} `json:"runs"`

	Artifacts struct {
		Deleted int     `json:"deleted"`
		IDs     []int64 `json:"ids"`
	} `json:"artifacts"`

	Releases struct {
		DeletedDrafts int      `json:"deleted_drafts"`
		Tags          []string `json:"tags"`
	} `json:"releases"`

	Notes []string `json:"notes"`
}

func (s *Service) SanitizeRepo(ctx context.Context, owner, repo string, rules Rules, dryRun bool) (*Report, error) {
	rpt := &Report{Owner: owner, Repo: repo, When: time.Now(), DryRun: dryRun}

	d1, k1, ids1, err := cleanRuns(ctx, s.cli, owner, repo, rules.Runs, dryRun)
	if err != nil {
		rpt.Notes = append(rpt.Notes, "runs: "+err.Error())
	}
	rpt.Runs.Deleted, rpt.Runs.Kept, rpt.Runs.IDs = d1, k1, ids1

	d2, ids2, err := cleanArtifacts(ctx, s.cli, owner, repo, rules.Artifacts, dryRun)
	if err != nil {
		rpt.Notes = append(rpt.Notes, "artifacts: "+err.Error())
	}
	rpt.Artifacts.Deleted, rpt.Artifacts.IDs = d2, ids2

	d3, tags, err := cleanReleases(ctx, s.cli, owner, repo, rules.Releases, dryRun)
	if err != nil {
		rpt.Notes = append(rpt.Notes, "releases: "+err.Error())
	}
	rpt.Releases.DeletedDrafts, rpt.Releases.Tags = d3, tags

	// persist report
	dir := filepath.Join(s.cfg.Runtime.ReportDir, time.Now().Format("2006-01-02"))
	_ = os.MkdirAll(dir, 0o755)

	jb, _ := json.MarshalIndent(rpt, "", "  ")
	md := toMarkdown(rpt)
	_ = os.WriteFile(filepath.Join(dir, fmt.Sprintf("%s_%s.json", owner, repo)), jb, 0o644)
	_ = os.WriteFile(filepath.Join(dir, fmt.Sprintf("%s_%s.md", owner, repo)), []byte(md), 0o644)

	// notify
	title := fmt.Sprintf("Repo sanitize: %s/%s (dry_run=%v)", owner, repo, dryRun)
	for _, n := range s.notifiers {
		_ = n.Send(ctx, title, md,
			Attachment{Name: "report.json", Body: jb},
			Attachment{Name: "report.md", Body: []byte(md)},
		)
	}
	return rpt, nil

}

func toMarkdown(r *Report) string {
	return fmt.Sprintf(`# Sanitize %s/%s
- when: %s
- dry_run: %v

## runs
- deleted: %d
- kept(success last): %d

## artifacts
- deleted: %d

## releases
- deleted drafts: %d
- tags: %v

notes:
%v
`,
		r.Owner, r.Repo, r.When.Format(time.RFC3339), r.DryRun,
		r.Runs.Deleted, r.Runs.Kept,
		r.Artifacts.Deleted,
		r.Releases.DeletedDrafts, r.Releases.Tags,
		r.Notes,
	)
}

/// internal/sanitize/types.go ///
// Package sanitize defines the configuration types used for sanitizing GitHub repositories.
package sanitize

type RunsRule struct {
	MaxAgeDays      int      `yaml:"max_age_days"`
	KeepSuccessLast int      `yaml:"keep_success_last"`
	OnlyWorkflows   []string `yaml:"only_workflows"`
}
type ArtifactsRule struct {
	MaxAgeDays int `yaml:"max_age_days"`
}
type ReleasesRule struct {
	DeleteDrafts bool `yaml:"delete_drafts"`
}

type Rules struct {
	Runs      RunsRule      `yaml:"runs"`
	Artifacts ArtifactsRule `yaml:"artifacts"`
	Releases  ReleasesRule  `yaml:"releases"`
}

type RepoCfg struct {
	Owner string `yaml:"owner"`
	Name  string `yaml:"name"`
	Rules Rules  `yaml:"rules"`
}

type Config struct {
	Runtime struct {
		DryRun    bool   `yaml:"dry_run"`
		ReportDir string `yaml:"report_dir"`
	} `yaml:"runtime"`
	GitHub struct {
		Repos []RepoCfg `yaml:"repos"`
	} `yaml:"github"`
}
