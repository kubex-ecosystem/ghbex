# LookAtni Code - Gerado automaticamente
# Data: 2025-08-15T11:12:25.624Z
# Fonte: ./
# Total de arquivos: 24

/// CODE_OF_CONDUCT.md ///
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
discord.gg/CCBJsFHT.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
<https://www.contributor-covenant.org/version/2/0/code_of_conduct.html>.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
<https://www.contributor-covenant.org/faq>. Translations are available at
<https://www.contributor-covenant.org/translations>.

/// CONTRIBUTING.md ///
# **Contribuindo para GHbex**

Obrigado por se interessar em contribuir para o **GHbex**! Estamos animados por ter você como parte da nossa comunidade. Este guia ajudará você a começar e contribuir de forma eficiente com o projeto.

---

## **Como Contribuir**

Existem várias maneiras de contribuir com o GHbex:

1. **Relatar Problemas (Issues)**
    - Encontre bugs ou problemas no código? Abra uma _issue_ detalhando o problema.
    - Inclua o máximo de informações possíveis: passos para reproduzir o problema, logs, versão do Go utilizada, etc.

2. **Sugerir Melhorias**
    - Tem uma ideia para melhorar o projeto? Compartilhe sua sugestão abrindo uma _issue_ com a tag `enhancement`.

3. **Enviar Pull Requests**
    - Quer corrigir um bug ou implementar algo novo? Envie um _pull request_ com suas alterações.

4. **Testar e Revisar Código**
    - Ajude a revisar _pull requests_ de outros contribuidores.
    - Execute os testes existentes e valide se as alterações propostas mantêm o sistema funcional.

---

## **Primeiros Passos**

### 1. **Clone o Repositório**
```bash
git clone https://github.com/<seu-usuario>/GHbex.git
cd GHbex
```

### 2. **Configure o Ambiente**
Certifique-se de ter o Go instalado:
- [Download Go](https://go.dev/dl/)

### 3. **Instale Dependências**
```bash
# Baixe os pacotes necessários
go mod download
```

### 4. **Execute os Testes**
Antes de fazer mudanças, execute os testes existentes:
```bash
go test ./...
```

---

## **Criando um Pull Request**

### **1. Faça um Fork do Repositório**
Crie um fork do projeto para seu próprio GitHub.

### **2. Crie uma Branch Nova**
```bash
git checkout -b sua-feature
```

### **3. Faça as Alterações**
Certifique-se de seguir as convenções de código e boas práticas do projeto.

### **4. Adicione Testes (se aplicável)**
Inclua casos de teste para validar a funcionalidade adicionada.

### **5. Execute os Testes**
Certifique-se de que todas as alterações e testes estão funcionando:
```bash
go test ./...
```

### **6. Commit e Push**
```bash
git add .
git commit -m "Descrição breve da alteração"
git push origin sua-feature
```

### **7. Abra o Pull Request**
Vá até o repositório original no GitHub e abra um _pull request_ explicando suas mudanças.

---

## **Padrões de Código**

### **Estilo de Código**
Este projeto segue as convenções de código do Go. Algumas recomendações:
- Use `gofmt` para formatar o código:
```bash
gofmt -w .
```

- Nomeie variáveis e funções de forma clara e descritiva.
- Divida funções longas em partes menores sempre que possível.

### **Commits**
Os commits devem ser claros e descritivos. Exemplos:
- `fix: corrigir bug na lógica de notificação`
- `feat: adicionar suporte ao notifier via Slack`

---

## **Boas Práticas**

1. **Seja Respeitoso e Acolhedor**  
   Este é um projeto de código aberto para todos. Respeite outros contribuidores e colabore de forma construtiva.

2. **Documente Suas Alterações**  
   Atualize o `README.md` ou a documentação, se necessário, para incluir suas mudanças.

3. **Adicione Testes Quando Possível**  
   Assegure-se de que qualquer nova funcionalidade seja acompanhada por testes.

4. **Seja Claro nos Relatórios de Problemas**  
   Ao abrir uma _issue_, seja detalhado e forneça o máximo de contexto.

---

## **Onde Obter Ajuda**

Se você precisar de assistência, sinta-se à vontade para:
- Abrir uma _issue_ com a tag `question`.
- Entrar em contato comigo através do e-mail ou LinkedIn listados no `README.md`.

---

## **Nosso Compromisso**

Nos comprometemos a revisar pull requests e issues o mais rápido possível. Valoramos sua contribuição e agradecemos pelo tempo dedicado ao projeto!

/// NOTICE.md ///
# NOTICE

This software is licensed under the MIT License. Below are additional notes on usage and attribution:

## Attribution Requirement (Optional)

- When distributing or using this software, please provide credit to the original author(s) in one or more of the following ways:
- Retain the copyright notice: `Copyright (c) 2025 Rafael Mori`.
- Include a link to the original project repository or website.

## Acknowledgment

This project was developed with the goal of enhancing usability and providing open access to its features.

For further information about the license and terms of use, please refer to the `LICENSE` file included with this project.

/// SECURITY.md ///
# Security Policy

## Supported Versions

Use this section to tell people about which versions of your project are
currently being supported with security updates.

| Version | Supported          |
| ------- | ------------------ |
| 5.1.x   | :white_check_mark: |
| 5.0.x   | :x:                |
| 4.0.x   | :white_check_mark: |
| < 4.0   | :x:                |

## Reporting a Vulnerability

Use this section to tell people how to report a vulnerability.

Tell them where to go, how often they can expect to get an update on a
reported vulnerability, what to expect if the vulnerability is accepted or
declined, etc.

/// cmd/cli/common.go ///
// Package cli provides common functionality for command-line interface applications.
package cli

import (
	"math/rand"
	"os"
	"strings"
)

var banners = []string{
	`
  ______  __    __ __
 /      \|  \  |  \  \
|  ▓▓▓▓▓▓\ ▓▓  | ▓▓ ▓▓____   ______  __    __
| ▓▓ __\▓▓ ▓▓__| ▓▓ ▓▓    \ /      \|  \  /  \
| ▓▓|    \ ▓▓    ▓▓ ▓▓▓▓▓▓▓\  ▓▓▓▓▓▓\\▓▓\/  ▓▓
| ▓▓ \▓▓▓▓ ▓▓▓▓▓▓▓▓ ▓▓  | ▓▓ ▓▓    ▓▓ >▓▓  ▓▓
| ▓▓__| ▓▓ ▓▓  | ▓▓ ▓▓__/ ▓▓ ▓▓▓▓▓▓▓▓/  ▓▓▓▓\
 \▓▓    ▓▓ ▓▓  | ▓▓ ▓▓    ▓▓\▓▓     \  ▓▓ \▓▓\
  \▓▓▓▓▓▓ \▓▓   \▓▓\▓▓▓▓▓▓▓  \▓▓▓▓▓▓▓\▓▓   \▓▓
`,
}

func GetDescriptions(descriptionArg []string, _ bool) map[string]string {
	var description, banner string

	if descriptionArg != nil {
		if strings.Contains(strings.Join(os.Args[0:], ""), "-h") {
			description = descriptionArg[0]
		} else {
			description = descriptionArg[1]
		}
	} else {
		description = ""
	}

	bannerRandLen := len(banners)
	bannerRandIndex := rand.Intn(bannerRandLen)
	banner = banners[bannerRandIndex]

	return map[string]string{"banner": banner, "description": description}
}

/// cmd/cli/server.go ///
package cli

import (
	"context"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/google/go-github/v61/github"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/rafa-mori/ghbex/internal/githubx"
	"github.com/rafa-mori/ghbex/internal/notify"
	"github.com/rafa-mori/ghbex/internal/sanitize"
)

type cfgRoot struct {
	Runtime struct {
		DryRun    bool   `yaml:"dry_run"`
		ReportDir string `yaml:"report_dir"`
	} `yaml:"runtime"`
	Server struct {
		Addr string `yaml:"addr"`
	} `yaml:"server"`
	GitHub struct {
		Auth struct {
			Kind           string `yaml:"kind"` // pat|app
			Token          string `yaml:"token"`
			AppID          int64  `yaml:"app_id"`
			InstallationID int64  `yaml:"installation_id"`
			PrivateKeyPath string `yaml:"private_key_path"`
			BaseURL        string `yaml:"base_url"`
			UploadURL      string `yaml:"upload_url"`
		} `yaml:"auth"`
		Repos []sanitize.RepoCfg `yaml:"repos"`
	} `yaml:"github"`
	Notifiers []struct {
		Type    string `yaml:"type"`
		Webhook string `yaml:"webhook"`
	} `yaml:"notifiers"`
}

func ServerCmdList() []*cobra.Command {
	var cmds []*cobra.Command

	// Define your server commands here
	cmds = append(cmds, startServer())
	cmds = append(cmds, stopServer())
	cmds = append(cmds, statusServer())
	return cmds
}

func stopServer() *cobra.Command {
	stopCmd := &cobra.Command{
		Use:   "stop",
		Short: "Stop the server",
		Annotations: GetDescriptions([]string{
			"This command stops server.",
			"This command stops the Grompt server and releases any resources held by it.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			// Stop server logic
		},
	}
	return stopCmd
}

func statusServer() *cobra.Command {
	statusCmd := &cobra.Command{
		Use:   "status",
		Short: "Get server status",
		Annotations: GetDescriptions([]string{
			"This command gets the status of the server.",
			"This command checks if the server is running and returns its status.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			// Get server status logic
		},
	}
	return statusCmd
}

func startServer() *cobra.Command {
	startCmd := &cobra.Command{
		Use:   "start",
		Short: "Start the server",
		Annotations: GetDescriptions([]string{
			"This command starts the server.",
			"This command initializes the server and starts waiting for help to build prompts.",
		}, false),
		Run: func(cmd *cobra.Command, args []string) {
			// Start server logic
		},
	}
	return startCmd
}

func main() {
	// load config
	b, err := os.ReadFile("config/sanitize.yaml")
	if err != nil {
		log.Printf("using example config: %v", err)
		b, _ = os.ReadFile("config/sanitize.yaml.example")
	}

	var cfg cfgRoot
	if err := yaml.Unmarshal(b, &cfg); err != nil {
		log.Fatal(err)
	}

	if cfg.Server.Addr == "" {
		cfg.Server.Addr = ":8088"
	}

	// build github client
	ctx := context.Background()
	var ghc *github.Client
	switch strings.ToLower(cfg.GitHub.Auth.Kind) {
	case "pat":
		ghc, err = githubx.NewPAT(ctx, githubx.PATConfig{
			Token:     os.ExpandEnv(cfg.GitHub.Auth.Token),
			BaseURL:   cfg.GitHub.Auth.BaseURL,
			UploadURL: cfg.GitHub.Auth.UploadURL,
		})
	case "app":
		ghc, err = githubx.NewApp(ctx, githubx.AppConfig{
			AppID:          cfg.GitHub.Auth.AppID,
			InstallationID: cfg.GitHub.Auth.InstallationID,
			PrivateKeyPath: cfg.GitHub.Auth.PrivateKeyPath,
			BaseURL:        cfg.GitHub.Auth.BaseURL,
			UploadURL:      cfg.GitHub.Auth.UploadURL,
		})
	default:
		err = errors.New("github.auth.kind must be pat|app")
	}

	if err != nil {
		log.Fatal(err)
	}

	// notifiers
	var notifiers []sanitize.Notifier
	for _, n := range cfg.Notifiers {
		switch n.Type {
		case "discord":
			notifiers = append(notifiers, notify.Discord{Webhook: os.ExpandEnv(n.Webhook)})
		case "stdout":
			notifiers = append(notifiers, notify.Stdout{})
		}
	}

	// service
	svc := sanitize.New(ghc, sanitize.Config{
		Runtime: struct {
			DryRun    bool   "yaml:\"dry_run\""
			ReportDir string "yaml:\"report_dir\""
		}{DryRun: cfg.Runtime.DryRun, ReportDir: cfg.Runtime.ReportDir},
		GitHub: struct {
			Repos []sanitize.RepoCfg "yaml:\"repos\""
		}{Repos: cfg.GitHub.Repos},
	}, notifiers...)

	// route: POST /admin/repos/{owner}/{repo}/sanitize?dry_run=1
	http.HandleFunc("/admin/repos/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "only POST", http.StatusMethodNotAllowed)
			return
		}
		// naive parse
		parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/admin/repos/"), "/")
		if len(parts) < 3 || parts[2] != "sanitize" {
			http.NotFound(w, r)
			return
		}
		owner, repo := parts[0], parts[1]
		dry := r.URL.Query().Get("dry_run")
		dryRun := dry == "1" || strings.EqualFold(dry, "true")

		// find rules (optional override via cfg)
		var rules sanitize.Rules
		for _, rc := range cfg.GitHub.Repos {
			if rc.Owner == owner && rc.Name == repo {
				rules = rc.Rules
				break
			}
		}

		var dummy sanitize.Rules
		dummy.Runs.MaxAgeDays = 30
		dummy.Artifacts.MaxAgeDays = 7
		dummy.Releases.DeleteDrafts = true

		if rules.Artifacts == dummy.Artifacts &&
			rules.Runs.MaxAgeDays == dummy.Runs.MaxAgeDays &&
			rules.Releases == dummy.Releases {
			// default sane rules
			rules.Runs.MaxAgeDays = 30
			rules.Artifacts.MaxAgeDays = 7
			rules.Releases.DeleteDrafts = true
		}

		rpt, err := svc.SanitizeRepo(r.Context(), owner, repo, rules, dryRun)
		if err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		_ = json.NewEncoder(w).Encode(rpt)
	})

	srv := &http.Server{
		Addr:              cfg.Server.Addr,
		ReadHeaderTimeout: 5 * time.Second,
	}

	log.Printf("listening on %s", cfg.Server.Addr)
	log.Fatal(srv.ListenAndServe())
}

/// cmd/main.go ///
package main

import (
	"github.com/rafa-mori/ghbex/internal/module"
	gl "github.com/rafa-mori/ghbex/internal/module/logger"
)

// This file is the entry point for the Ghbex CLI application.
// It initializes the logger and starts the application by executing the main command.
// It allows the application to be run as a standalone CLI tool.

// main initializes the logger and creates a new Ghbex instance.
func main() {
	if err := module.RegX().Command().Execute(); err != nil {
		gl.Log("fatal", err.Error())
	}
}

/// config/sanitize.yaml ///
runtime:
  dry_run: true
  report_dir: ./_reports

server:
  addr: ":8088"

github:
  auth:
    kind: "pat" # "pat" | "app"
    token: "${GITHUB_TOKEN}" # se kind=pat
    app_id: 0 # se kind=app
    installation_id: 0 # se kind=app
    private_key_path: "./secrets/gh_app.pem"
    base_url: "" # GHES: https://ghe.example/api/v3/
    upload_url: "" # GHES: https://ghe.example/api/uploads/
  repos:
    - owner: "rafa-mori"
      name: "grompt"
      rules:
        runs:
          max_age_days: 30
          keep_success_last: 10
          only_workflows: [] # ["build.yml","release.yml"]
        artifacts:
          max_age_days: 7
        releases:
          delete_drafts: true

notifiers:
  - type: "stdout"
  - type: "discord"
    webhook: "${DISCORD_WEBHOOK_URL}"

/// docs/README.md ///
# MCP Repo Sanitizer (Go + google/go-github)

MVP para higienizar repositórios GitHub:

- **Autenticação**: PAT *ou* GitHub App (JWT + Installation Token) — sem libs externas.
- **Ações**: apagar **workflow runs** antigos, **artifacts** velhos, **releases** em **draft**.
- **HTTP**: `POST /admin/repos/{owner}/{repo}/sanitize?dry_run=true`
- **Reports**: salva `.json` e `.md` em `_reports/YYYY-MM-DD/`.
- **Discord**: envia resumo via webhook.

> Pensado para encaixar no seu BE atual. Se já tiver API Gateway/Router, só “wirear” o `Service` e o `Client`.

## Uso rápido

```bash
# deps
go mod tidy

# configure
cp config/sanitize.yaml.example config/sanitize.yaml
# set DISCORD_WEBHOOK_URL se quiser notificação

# run
go run ./cmd/server

# testar (dry-run)
curl -X POST "http://localhost:8088/admin/repos/rafa-mori/grompt/sanitize?dry_run=true" | jq
````

## Estrutura

- `internal/githubx`: client GitHub (PAT/App), sem `ghinstallation`.
- `internal/sanitize`: regras e execução (runs/artifacts/releases).
- `internal/notify`: Discord notifier simples.
- `cmd/server`: HTTP mínimo pra você colar no seu gateway depois.

## Notas

- Para **GitHub App**, coloque o `.pem` no caminho do `config`.
- Para **GHES**, configure `base_url`/`upload_url` (ex.: `https://ghe.example/api/v3/`).
- **Dry-run** por padrão no YAML. Só desligue quando estiver confortável.

---

/// internal/githubx/appjwt.go ///
package githubx

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

func makeAppJWT(priv *rsa.PrivateKey, appID int64, dur time.Duration) (string, error) {
	now := time.Now()
	iat := now.Add(-30 * time.Second).Unix()
	exp := now.Add(dur).Unix()

	header := map[string]any{"alg": "RS256", "typ": "JWT"}
	payload := map[string]any{"iat": iat, "exp": exp, "iss": fmt.Sprintf("%d", appID)}

	hb, _ := json.Marshal(header)
	pb, _ := json.Marshal(payload)

	enc := func(b []byte) string { return base64.RawURLEncoding.EncodeToString(b) }

	unsigned := enc(hb) + "." + enc(pb)
	sig, err := rsa.SignPKCS1v15(rand.Reader, priv, crypto.SHA256, sha256Bytes(unsigned))
	if err != nil {
		return "", err
	}
	return unsigned + "." + enc(sig), nil
}

func sha256Bytes(s string) []byte {
	h := crypto.SHA256.New()
	h.Write([]byte(s))
	return h.Sum(nil)
}

func createInstallationToken(hc *http.Client, base string, instID int64, jwt string) (token string, expiry time.Time, err error) {
	url := fmt.Sprintf("%s/app/installations/%d/access_tokens", base, instID)
	req, _ := http.NewRequest("POST", url, bytes.NewReader([]byte("{}")))
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Authorization", "Bearer "+jwt)
	resp, err := hc.Do(req)
	if err != nil {
		return "", time.Time{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode/100 != 2 {
		return "", time.Time{}, fmt.Errorf("installation token http %d", resp.StatusCode)
	}
	var out struct {
		Token     string    `json:"token"`
		ExpiresAt time.Time `json:"expires_at"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&out); err != nil {
		return "", time.Time{}, err
	}
	return out.Token, out.ExpiresAt, nil
}

/// internal/githubx/client.go ///
// Package githubx provides a GitHub client with support for both PAT and App authentication.
package githubx

import (
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/google/go-github/v61/github"
	"golang.org/x/oauth2"
)

// -------- PAT --------

type PATConfig struct {
	Token     string
	BaseURL   string
	UploadURL string
}

func NewPAT(ctx context.Context, cfg PATConfig) (*github.Client, error) {
	if strings.TrimSpace(cfg.Token) == "" {
		return nil, errors.New("missing PAT token")
	}
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: cfg.Token})
	hc := oauth2.NewClient(ctx, ts)
	if cfg.BaseURL != "" {
		upload := cfg.UploadURL
		if upload == "" {
			upload = strings.Replace(cfg.BaseURL, "/api/v3/", "/api/uploads/", 1)
		}
		return github.NewEnterpriseClient(cfg.BaseURL, upload, hc)
	}
	return github.NewClient(hc), nil
}

// -------- GitHub App (sem ghinstallation) --------

type AppConfig struct {
	AppID          int64
	InstallationID int64
	PrivateKeyPath string
	BaseURL        string
	UploadURL      string
}

func NewApp(ctx context.Context, cfg AppConfig) (*github.Client, error) {
	if cfg.AppID == 0 || cfg.InstallationID == 0 || cfg.PrivateKeyPath == "" {
		return nil, errors.New("missing GitHub App config")
	}
	keyPEM, err := os.ReadFile(cfg.PrivateKeyPath)
	if err != nil {
		return nil, err
	}
	priv, err := parseRSAPrivateKeyFromPEM(keyPEM)
	if err != nil {
		return nil, fmt.Errorf("invalid app private key: %w", err)
	}

	baseAPI := cfg.BaseURL
	if baseAPI == "" {
		baseAPI = "https://api.github.com/"
	}
	tokenSrc := &installationTokenSource{
		appID:          cfg.AppID,
		installationID: cfg.InstallationID,
		privateKey:     priv,
		apiBase:        strings.TrimRight(baseAPI, "/"),
		client:         http.DefaultClient,
	}

	hc := oauth2.NewClient(ctx, tokenSrc)
	if cfg.BaseURL != "" {
		upload := cfg.UploadURL
		if upload == "" {
			upload = strings.Replace(cfg.BaseURL, "/api/v3/", "/api/uploads/", 1)
		}
		return github.NewEnterpriseClient(cfg.BaseURL, upload, hc)
	}
	return github.NewClient(hc), nil

}

// installationTokenSource gera e renova tokens de instalação sob demanda.
type installationTokenSource struct {
	appID          int64
	installationID int64
	privateKey     *rsa.PrivateKey
	apiBase        string
	client         *http.Client

	mu    sync.Mutex
	token *oauth2.Token
}

func (s *installationTokenSource) Token() (*oauth2.Token, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	// ainda válido?
	if s.token != nil && s.token.Expiry.After(time.Now().Add(30*time.Second)) {
		return s.token, nil
	}

	// gera JWT do App
	jwt, err := makeAppJWT(s.privateKey, s.appID, 9*time.Minute)
	if err != nil {
		return nil, err
	}

	// troca por installation token
	tok, exp, err := createInstallationToken(s.client, s.apiBase, s.installationID, jwt)
	if err != nil {
		return nil, err
	}
	s.token = &oauth2.Token{
		AccessToken: tok,
		TokenType:   "token",
		Expiry:      exp,
	}
	return s.token, nil

}

func parseRSAPrivateKeyFromPEM(pemBytes []byte) (*rsa.PrivateKey, error) {
	block, _ := pem.Decode(pemBytes)
	if block == nil {
		return nil, errors.New("no PEM block found")
	}
	switch block.Type {
	case "RSA PRIVATE KEY":
		return x509.ParsePKCS1PrivateKey(block.Bytes)
	case "PRIVATE KEY":
		k, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		if err != nil {
			return nil, err
		}
		rsaKey, ok := k.(*rsa.PrivateKey)
		if !ok {
			return nil, errors.New("not RSA key")
		}
		return rsaKey, nil
	default:
		return nil, errors.New("unsupported PEM type: " + block.Type)
	}
}

/// internal/module/info/application.go ///
// Package manifest provides functionality to read and parse the application manifest.
package manifest

import (
	_ "embed"
	"encoding/json"

	l "github.com/rafa-mori/logz"
)

//go:embed manifest.json
var manifestJSONData []byte
var application Manifest

type manifest struct {
	Manifest
	Name            string   `json:"name"`
	ApplicationName string   `json:"application"`
	Bin             string   `json:"bin"`
	Version         string   `json:"version"`
	Repository      string   `json:"repository"`
	Aliases         []string `json:"aliases,omitempty"`
	Homepage        string   `json:"homepage,omitempty"`
	Description     string   `json:"description,omitempty"`
	Main            string   `json:"main,omitempty"`
	Author          string   `json:"author,omitempty"`
	License         string   `json:"license,omitempty"`
	Keywords        []string `json:"keywords,omitempty"`
	Platforms       []string `json:"platforms,omitempty"`
	LogLevel        string   `json:"log_level,omitempty"`
	Debug           bool     `json:"debug,omitempty"`
	ShowTrace       bool     `json:"show_trace,omitempty"`
	Private         bool     `json:"private,omitempty"`
}
type Manifest interface {
	GetName() string
	GetVersion() string
	GetAliases() []string
	GetRepository() string
	GetHomepage() string
	GetDescription() string
	GetMain() string
	GetBin() string
	GetAuthor() string
	GetLicense() string
	GetKeywords() []string
	GetPlatforms() []string
	IsPrivate() bool
}

func (m *manifest) GetName() string        { return m.Name }
func (m *manifest) GetVersion() string     { return m.Version }
func (m *manifest) GetAliases() []string   { return m.Aliases }
func (m *manifest) GetRepository() string  { return m.Repository }
func (m *manifest) GetHomepage() string    { return m.Homepage }
func (m *manifest) GetDescription() string { return m.Description }
func (m *manifest) GetMain() string        { return m.Main }
func (m *manifest) GetBin() string         { return m.Bin }
func (m *manifest) GetAuthor() string      { return m.Author }
func (m *manifest) GetLicense() string     { return m.License }
func (m *manifest) GetKeywords() []string  { return m.Keywords }
func (m *manifest) GetPlatforms() []string { return m.Platforms }
func (m *manifest) IsPrivate() bool        { return m.Private }

func init() {
	_, err := GetManifest()
	if err != nil {
		l.GetLogger("Kubex")
		l.Fatal("Failed to get manifest: " + err.Error())
	}
}

func GetManifest() (Manifest, error) {
	if application != nil {
		return application, nil
	}

	var m manifest
	if err := json.Unmarshal(manifestJSONData, &m); err != nil {
		return nil, err
	}

	application = &m
	return application, nil
}

/// internal/module/info/manifest.json ///
{
  "name": "Kubex - Grompt",
  "application": "grompt",
  "version": "1.2.0",
  "private": false,
  "published": true,
  "aliases": [
    "grompt",
    "krompt"
  ],
  "repository": "https://github.com/rafa-mori/grompt",
  "homepage": "https://grompt.rafa-mori.dev/",
  "description": "Kubex - Grompt is a profissional AI prompt context object kind like: agents, prompts, API calls, and more.",
  "main": "cmd/main.go",
  "bin": "grompt",
  "author": "Rafael Mori <faelmori@gmail.com>",
  "organization": "rafa-mori",
  "license": "MIT",
  "keywords": [
    "grompt",
    "kubex",
    "file-markers",
    "control",
    "command-line",
    "tool",
    "management"
  ],
  "platforms": [
    "linux/amd64"
  ],
  "dependencies": [
    "tar",
    "gzip",
    "curl",
    "git",
    "zip",
    "unzip",
    "jq",
    "upx"
  ]
}

/// internal/module/logger/logger.go ///
// Package logger provides a logging utility for Go applications.
package logger

import (
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strings"
	"time"

	manifest "github.com/rafa-mori/ghbex/internal/module/info"
	l "github.com/rafa-mori/logz"
)

type GLog[T any] interface {
	GetLogger() l.Logger
	GetLogLevel() LogLevel
	GetShowTrace() bool
	GetDebug() bool
	SetLogLevel(string)
	SetDebug(bool)
	SetShowTrace(bool)
	ObjLog(*T, string, ...any)
	Log(string, ...any)
}

type gLog[T any] struct {
	l.Logger
	gLogLevel  LogLevel // Global log level
	gShowTrace bool     // Flag to show trace in logs
	gDebug     bool     // Flag to show debug messages
}

type LogType string
type LogLevel int

var (
	info      manifest.Manifest
	debug     bool
	showTrace bool
	logLevel  string
	g         *gLog[l.Logger] // Global logger instance
	Logger    GLog[l.Logger]
	err       error
)

const (
	// LogTypeDebug is the log type for debug messages.
	LogTypeDebug LogType = "debug"
	// LogTypeNotice is the log type for notice messages.
	LogTypeNotice LogType = "notice"
	// LogTypeInfo is the log type for informational messages.
	LogTypeInfo LogType = "info"
	// LogTypeWarn is the log type for warning messages.
	LogTypeWarn LogType = "warn"
	// LogTypeError is the log type for error messages.
	LogTypeError LogType = "error"
	// LogTypeFatal is the log type for fatal error messages.
	LogTypeFatal LogType = "fatal"
	// LogTypePanic is the log type for panic messages.
	LogTypePanic LogType = "panic"
	// LogTypeSuccess is the log type for success messages.
	LogTypeSuccess LogType = "success"
)

const (
	// LogLevelDebug 0
	LogLevelDebug LogLevel = iota
	// LogLevelNotice 1
	LogLevelNotice
	// LogLevelInfo 2
	LogLevelInfo
	// LogLevelSuccess 3
	LogLevelSuccess
	// LogLevelWarn 4
	LogLevelWarn
	// LogLevelError 5
	LogLevelError
	// LogLevelFatal 6
	LogLevelFatal
	// LogLevelPanic 7
	LogLevelPanic
)

func getEnvOrDefault[T string | int | bool](key string, defaultValue T) T {
	value, exists := os.LookupEnv(key)
	if !exists {
		return defaultValue
	} else {
		valInterface := reflect.ValueOf(value)
		if valInterface.Type().ConvertibleTo(reflect.TypeFor[T]()) {
			return valInterface.Convert(reflect.TypeFor[T]()).Interface().(T)
		}
	}
	return defaultValue
}

func init() {
	if info == nil {
		info, err = manifest.GetManifest()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get info manifest: %v\n", err)
			os.Exit(1)
		}
		l.GetLogger(info.GetBin())
	}
	if Logger == nil {
		Logger = GetLogger[l.Logger](nil)
		if logger, ok := Logger.(*gLog[l.Logger]); ok {
			g = logger
			logLevel = getEnvOrDefault("GOBE_LOG_LEVEL", "error")
			debug = getEnvOrDefault("GOBE_DEBUG", false)
			showTrace = getEnvOrDefault("GOBE_SHOW_TRACE", false)
			//g.gLogLevel = LogLevelError
			g.gLogLevel = LogLevelInfo
			g.gShowTrace = showTrace
			g.gDebug = debug
		}
	}
}

func setLogLevel(logLevel string) {
	if g == nil || Logger == nil {
		_ = GetLogger[l.Logger](nil)
	}
	switch strings.ToLower(logLevel) {
	case "debug":
		g.gLogLevel = LogLevelDebug
		g.SetLevel("debug")
	case "info":
		g.gLogLevel = LogLevelInfo
		g.SetLevel("info")
	case "warn":
		g.gLogLevel = LogLevelWarn
		g.SetLevel("warn")
	case "error":
		g.gLogLevel = LogLevelError
		g.SetLevel("error")
	case "fatal":
		g.gLogLevel = LogLevelFatal
		g.SetLevel("fatal")
	case "panic":
		g.gLogLevel = LogLevelPanic
		g.SetLevel("panic")
	case "notice":
		g.gLogLevel = LogLevelNotice
		g.SetLevel("notice")
	case "success":
		g.gLogLevel = LogLevelSuccess
		g.SetLevel("success")
	default:
		// logLevel = "error"
		// g.gLogLevel = LogLevelError
		logLevel = "info"
		g.gLogLevel = LogLevelInfo
		g.SetLevel(logLevel)
	}
}
func getShowTrace() bool {
	if debug {
		return true
	} else {
		if !showTrace {
			return false
		} else {
			return true
		}
	}
}
func willPrintLog(logType string) bool {
	if debug {
		return true
	} else {
		lTypeInt := LogLevelError
		switch strings.ToLower(logType) {
		case "debug":
			lTypeInt = LogLevelDebug
		case "info":
			lTypeInt = LogLevelInfo
		case "warn":
			lTypeInt = LogLevelWarn
		case "error":
			lTypeInt = LogLevelError
		case "notice":
			lTypeInt = LogLevelNotice
		case "success":
			lTypeInt = LogLevelSuccess
		case "fatal":
			lTypeInt = LogLevelFatal
		case "panic":
			lTypeInt = LogLevelPanic
		default:
			lTypeInt = LogLevelError
		}
		return lTypeInt >= g.gLogLevel
	}
}
func getCtxMessageMap(logType, funcName, file string, line int) map[string]any {
	ctxMessageMap := map[string]any{
		"context":   funcName,
		"file":      file,
		"line":      line,
		"logType":   logType,
		"timestamp": time.Now().Format(time.RFC3339),
		"version":   info.GetVersion(),
	}
	if !debug && !showTrace {
		ctxMessageMap["showData"] = false
	} else {
		ctxMessageMap["showData"] = getShowTrace()
	}
	if info != nil {
		ctxMessageMap["appName"] = info.GetName()
		ctxMessageMap["bin"] = info.GetBin()
		ctxMessageMap["version"] = info.GetVersion()
	}
	return ctxMessageMap
}
func getFuncNameMessage(lgr l.Logger) (string, int, string) {
	if lgr == nil {
		return "", 0, ""
	}
	if getShowTrace() {
		pc, file, line, ok := runtime.Caller(3)
		if !ok {
			lgr.ErrorCtx("Log: unable to get caller information", nil)
			return "", 0, ""
		}
		funcName := runtime.FuncForPC(pc).Name()
		if strings.Contains(funcName, "LogObjLogger") {
			pc, file, line, ok = runtime.Caller(4)
			if !ok {
				lgr.ErrorCtx("Log: unable to get caller information", nil)
				return "", 0, ""
			}
			funcName = runtime.FuncForPC(pc).Name()
		}
		return funcName, line, file
	}
	return "", 0, ""
}
func getFullMessage(messages ...any) string {
	fullMessage := ""
	for _, msg := range messages {
		if msg != nil {
			if str, ok := msg.(string); ok {
				fullMessage += str + " "
			} else {
				fullMessage += fmt.Sprintf("%v ", msg)
			}
		}
	}
	return strings.TrimSpace(fullMessage)
}

func SetDebug(d bool) {
	if g == nil || Logger == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.gDebug = d
	if d {
		g.SetLevel("debug")
	} else {
		switch g.gLogLevel {
		case LogLevelDebug:
			g.SetLevel("debug")
		case LogLevelInfo:
			g.SetLevel("info")
		case LogLevelWarn:
			g.SetLevel("warn")
		case LogLevelError:
			g.SetLevel("error")
		case LogLevelFatal:
			g.SetLevel("fatal")
		case LogLevelPanic:
			g.SetLevel("panic")
		case LogLevelNotice:
			g.SetLevel("notice")
		case LogLevelSuccess:
			g.SetLevel("success")
		default:
			g.SetLevel("info")
		}
	}
}
func GetLogger[T any](obj *T) GLog[l.Logger] {
	if g == nil || Logger == nil {
		g = &gLog[l.Logger]{
			Logger:     l.GetLogger(info.GetBin()),
			gLogLevel:  LogLevelInfo,
			gShowTrace: showTrace,
			gDebug:     debug,
		}
		Logger = g
	}
	if obj == nil {
		return Logger
	}
	var lgr l.Logger
	if objValueLogger := reflect.ValueOf(obj).Elem().MethodByName("GetLogger"); !objValueLogger.IsValid() {
		if objValueLogger = reflect.ValueOf(obj).Elem().FieldByName("Logger"); !objValueLogger.IsValid() {
			g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
				"context":  "Log",
				"logType":  "error",
				"object":   obj,
				"msg":      "object does not have a logger field",
				"showData": getShowTrace(),
			})
			return g
		} else {
			lgrC := objValueLogger.Convert(reflect.TypeFor[l.Logger]())
			if lgrC.IsNil() {
				lgrC = reflect.ValueOf(g.Logger)
			}
			if lgr = lgrC.Interface().(l.Logger); lgr == nil {
				lgr = g.Logger
			}
		}
	} else {
		lgr = g
	}
	if lgr == nil {
		g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
			"context":  "Log",
			"logType":  "error",
			"object":   obj,
			"msg":      "object does not have a logger field",
			"showData": getShowTrace(),
		})
		return Logger
	}
	return &gLog[l.Logger]{
		Logger:     lgr,
		gLogLevel:  g.gLogLevel,
		gShowTrace: g.gShowTrace,
		gDebug:     g.gDebug,
	}
}
func LogObjLogger[T any](obj *T, logType string, messages ...any) {
	lgr := GetLogger(obj)
	if lgr == nil {
		g.ErrorCtx(fmt.Sprintf("log object (%s) does not have a logger field", reflect.TypeFor[T]()), map[string]any{
			"context":  "Log",
			"logType":  logType,
			"object":   obj,
			"msg":      messages,
			"showData": getShowTrace(),
		})
		return
	}

	fullMessage := getFullMessage(messages...)
	logType = strings.ToLower(logType)
	funcName, line, file := getFuncNameMessage(lgr.GetLogger())

	ctxMessageMap := getCtxMessageMap(logType, funcName, file, line)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			logging(lgr.GetLogger(), lType, fullMessage, ctxMessageMap)
		} else {
			lgr.GetLogger().ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		lgr.GetLogger().InfoCtx(fullMessage, ctxMessageMap)
	}
}
func Log(logType string, messages ...any) {
	funcName, line, file := getFuncNameMessage(g.Logger)
	fullMessage := getFullMessage(messages...)
	logType = strings.ToLower(logType)
	ctxMessageMap := getCtxMessageMap(logType, funcName, file, line)
	if logType != "" {
		if reflect.TypeOf(logType).ConvertibleTo(reflect.TypeFor[LogType]()) {
			lType := LogType(logType)
			ctxMessageMap["logType"] = logType
			logging(g.Logger, lType, fullMessage, ctxMessageMap)
		} else {
			g.ErrorCtx(fmt.Sprintf("logType (%s) is not valid", logType), ctxMessageMap)
		}
	} else {
		logging(g.Logger, LogTypeInfo, fullMessage, ctxMessageMap)
	}
}
func logging(lgr l.Logger, lType LogType, fullMessage string, ctxMessageMap map[string]any) {
	lt := strings.ToLower(string(lType))
	if _, exist := ctxMessageMap["showData"]; !exist {
		ctxMessageMap["showData"] = getShowTrace()
	}
	if willPrintLog(lt) {
		switch lType {
		case LogTypeInfo:
			lgr.InfoCtx(fullMessage, ctxMessageMap)
		case LogTypeDebug:
			lgr.DebugCtx(fullMessage, ctxMessageMap)
		case LogTypeError:
			lgr.ErrorCtx(fullMessage, ctxMessageMap)
		case LogTypeWarn:
			lgr.WarnCtx(fullMessage, ctxMessageMap)
		case LogTypeNotice:
			lgr.NoticeCtx(fullMessage, ctxMessageMap)
		case LogTypeSuccess:
			lgr.SuccessCtx(fullMessage, ctxMessageMap)
		case LogTypeFatal:
			lgr.FatalCtx(fullMessage, ctxMessageMap)
		case LogTypePanic:
			lgr.FatalCtx(fullMessage, ctxMessageMap)
		default:
			lgr.InfoCtx(fullMessage, ctxMessageMap)
		}
	} else {
		ctxMessageMap["msg"] = fullMessage
		ctxMessageMap["showData"] = false
		lgr.DebugCtx("Log: message not printed due to log level", ctxMessageMap)
	}
}

func (g *gLog[T]) GetLogger() l.Logger                 { return g.Logger }
func (g *gLog[T]) GetLogLevel() LogLevel               { return g.gLogLevel }
func (g *gLog[T]) GetShowTrace() bool                  { return g.gShowTrace }
func (g *gLog[T]) GetDebug() bool                      { return g.gDebug }
func (g *gLog[T]) SetLogLevel(logLevel string)         { setLogLevel(logLevel) }
func (g *gLog[T]) SetShowTrace(showTrace bool)         { g.gShowTrace = showTrace }
func (g *gLog[T]) SetDebug(d bool)                     { SetDebug(d); g.gDebug = d }
func (g *gLog[T]) Log(logType string, messages ...any) { Log(logType, messages...) }
func (g *gLog[T]) ObjLog(obj *T, logType string, messages ...any) {
	LogObjLogger(obj, logType, messages...)
}

func (g *gLog[T]) Notice(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("notice", m...)
}
func (g *gLog[T]) Info(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("info", m...)
}
func (g *gLog[T]) Debug(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("debug", m...)
}
func (g *gLog[T]) Warn(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("warn", m...)
}
func (g *gLog[T]) Error(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("error", m...)
}
func (g *gLog[T]) Fatal(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("fatal", m...)
}
func (g *gLog[T]) Panic(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("fatal", m...)
}
func (g *gLog[T]) Success(m ...any) {
	if g == nil {
		_ = GetLogger[l.Logger](nil)
	}
	g.Log("success", m...)
}

func NewLogger[T any](prefix string) GLog[T] {
	return &gLog[T]{
		Logger:     l.NewLogger(prefix),
		gLogLevel:  LogLevelError,
		gShowTrace: false,
		gDebug:     false,
	}
}

/// internal/module/module.go ///
// Package module provides internal types and functions for the Ghbex application.
package module

import (
	cc "github.com/rafa-mori/ghbex/cmd/cli"
	gl "github.com/rafa-mori/ghbex/internal/module/logger"
	vs "github.com/rafa-mori/ghbex/internal/module/version"
	"github.com/spf13/cobra"

	"os"
	"strings"
)

type Ghbex struct {
	parentCmdName string
	PrintBanner   bool
}

func (m *Ghbex) Alias() string {
	return ""
}
func (m *Ghbex) ShortDescription() string {
	return "Ghbex a tool for building prompts with AI assistance."
}
func (m *Ghbex) LongDescription() string {
	return `Ghbex: A tool for building prompts with AI assistance using real engineering practices. Better prompts, better results.., Awesome prompts, AMAZING results !!!`
}
func (m *Ghbex) Usage() string {
	return "ghbex [command] [args]"
}
func (m *Ghbex) Examples() []string {
	return []string{
		"ghbex start",
		"ghbex stop",
		"ghbex status",
	}
}
func (m *Ghbex) Active() bool {
	return true
}
func (m *Ghbex) Module() string {
	return "ghbex"
}
func (m *Ghbex) Execute() error {
	return m.Command().Execute()
}
func (m *Ghbex) Command() *cobra.Command {
	gl.Log("debug", "Starting Ghbex CLI...")

	var rtCmd = &cobra.Command{
		Use:     m.Module(),
		Aliases: []string{m.Alias()},
		Example: m.concatenateExamples(),
		Version: vs.GetVersion(),
		Annotations: cc.GetDescriptions([]string{
			m.LongDescription(),
			m.ShortDescription(),
		}, m.PrintBanner),
	}

	rtCmd.AddCommand(cc.ServerCmdList()...)
	rtCmd.AddCommand(vs.CliCommand())

	// Set usage definitions for the command and its subcommands
	setUsageDefinition(rtCmd)
	for _, c := range rtCmd.Commands() {
		setUsageDefinition(c)
		if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
			if c.Short == "" {
				c.Short = c.Annotations["description"]
			}
		}
	}

	return rtCmd
}
func (m *Ghbex) SetParentCmdName(rtCmd string) {
	m.parentCmdName = rtCmd
}
func (m *Ghbex) concatenateExamples() string {
	examples := ""
	rtCmd := m.parentCmdName
	if rtCmd != "" {
		rtCmd = rtCmd + " "
	}
	for _, example := range m.Examples() {
		examples += rtCmd + example + "\n  "
	}
	return examples
}

/// internal/module/usage.go ///
package module

import (
	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

// colorYellow, colorGreen, colorBlue, colorRed, and colorHelp are utility functions
// that return a string formatted with the specified color using the fatih/color package.
// These functions are used to colorize output in the CLI usage template.
// They are registered as template functions in the CLI usage template to allow
// coloring specific parts of the command usage output.
func colorYellow(s string) string {
	return color.New(color.FgYellow).SprintFunc()(s)
}

func colorGreen(s string) string {
	return color.New(color.FgGreen).SprintFunc()(s)
}

func colorBlue(s string) string {
	return color.New(color.FgBlue).SprintFunc()(s)
}

func colorRed(s string) string {
	return color.New(color.FgRed).SprintFunc()(s)
}

func colorHelp(s string) string {
	return color.New(color.FgCyan).SprintFunc()(s)
}

func hasServiceCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] == "true" {
			return true
		}
	}
	return false
}

func hasModuleCommands(cmds []*cobra.Command) bool {
	for _, cmd := range cmds {
		if cmd.Annotations["service"] != "true" {
			return true
		}
	}
	return false
}

func setUsageDefinition(cmd *cobra.Command) {
	cobra.AddTemplateFunc("colorYellow", colorYellow)
	cobra.AddTemplateFunc("colorGreen", colorGreen)
	cobra.AddTemplateFunc("colorRed", colorRed)
	cobra.AddTemplateFunc("colorBlue", colorBlue)
	cobra.AddTemplateFunc("colorHelp", colorHelp)
	cobra.AddTemplateFunc("hasServiceCommands", hasServiceCommands)
	cobra.AddTemplateFunc("hasModuleCommands", hasModuleCommands)

	// Altera o template de uso do cobra
	cmd.SetUsageTemplate(cliUsageTemplate)
}

var cliUsageTemplate = `{{- if index .Annotations "banner" }}{{colorBlue (index .Annotations "banner")}}{{end}}{{- if (index .Annotations "description") }}
{{index .Annotations "description"}}
{{- end }}

{{colorYellow "Usage:"}}{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command] [args]{{end}}{{if gt (len .Aliases) 0}}

{{colorYellow "Aliases:"}}
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

{{colorYellow "Example:"}}
  {{.Example}}{{end}}{{if .HasAvailableSubCommands}}
{{colorYellow "Available Commands:"}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{colorGreen (rpad .Name .NamePadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

{{colorYellow "Flags:"}}
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasAvailableInheritedFlags}}

{{colorYellow "Global Options:"}}
  {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces | colorHelp}}{{end}}{{if .HasHelpSubCommands}}

{{colorYellow "Additional help topics:"}}
{{range .Commands}}{{if .IsHelpCommand}}
  {{colorGreen (rpad .CommandPath .CommandPathPadding) }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasSubCommands}}

{{colorYellow (printf "Use \"%s [command] --help\" for more information about a command." .CommandPath)}}{{end}}
`

/// internal/module/version/semantic.go ///
// Package version provides functionality to manage and check the version of the Kubex Horizon CLI tool.
// It includes methods to retrieve the current version, check for the latest version,
package version

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	manifest "github.com/rafa-mori/ghbex/internal/module/info"
	"github.com/rafa-mori/ghbex/internal/module/logger"
	"github.com/spf13/cobra"
)

var gl = logger.GetLogger[ServiceImpl](nil)
var (
	info manifest.Manifest
	vrs  Service
	err  error
)

func init() {
	if info == nil {
		info, err = manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
}

type Service interface {
	// GetLatestVersion retrieves the latest version from the Git repository.
	GetLatestVersion() (string, error)
	// GetCurrentVersion returns the current version of the service.
	GetCurrentVersion() string
	// IsLatestVersion checks if the current version is the latest version.
	IsLatestVersion() (bool, error)
	// GetName returns the name of the service.
	GetName() string
	// GetVersion returns the current version of the service.
	GetVersion() string
	// GetRepository returns the Git repository URL of the service.
	GetRepository() string
	// setLastCheckedAt sets the last checked time for the version.
	setLastCheckedAt(time.Time)
	// updateLatestVersion updates the latest version from the Git repository.
	updateLatestVersion() error
}
type ServiceImpl struct {
	manifest.Manifest
	gitModelURL    string
	latestVersion  string
	lastCheckedAt  time.Time
	currentVersion string
}

func init() {
	if info == nil {
		var err error
		info, err = manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
		}
	}
	if vrs == nil {
		vrs = NewVersionService()
	}
}

func getLatestTag(repoURL string) (string, error) {
	defer func() {
		if rec := recover(); rec != nil {
			gl.Log("error", "Recovered from panic in getLatestTag: %v", rec)
			err = fmt.Errorf("panic occurred while fetching latest tag: %v", rec)
		}
	}()

	defer func() {
		if vrs == nil {
			vrs = NewVersionService()
		}
		vrs.setLastCheckedAt(time.Now())
	}()

	if info == nil {
		var err error
		info, err = manifest.GetManifest()
		if err != nil {
			return "", fmt.Errorf("failed to get manifest: %w", err)
		}
	}
	if info.IsPrivate() {
		return "", fmt.Errorf("cannot fetch latest tag for private repositories")
	}

	if repoURL == "" {
		repoURL = info.GetRepository()
		if repoURL == "" {
			return "", fmt.Errorf("repository URL is not set")
		}
	}

	apiURL := fmt.Sprintf("%s/tags", repoURL)
	resp, err := http.Get(apiURL)
	if err != nil {
		return "", err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch tags: %s", resp.Status)
	}
	type Tag struct {
		Name string `json:"name"`
	}

	// Decode the JSON response into a slice of Tag structs
	// This assumes the API returns a JSON array of tags.
	// Adjust the decoding logic based on the actual API response structure.
	if resp.Header.Get("Content-Type") != "application/json" {
		return "", fmt.Errorf("expected application/json, got %s", resp.Header.Get("Content-Type"))
	}

	var tags []Tag
	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return "", err
	}

	if len(tags) == 0 {
		return "", fmt.Errorf("no tags found")
	}
	return tags[0].Name, nil
}
func (v *ServiceImpl) updateLatestVersion() error {
	if info.IsPrivate() {
		return fmt.Errorf("cannot fetch latest version for private repositories")
	}
	repoURL := strings.TrimSuffix(v.gitModelURL, ".git")
	tag, err := getLatestTag(repoURL)
	if err != nil {
		return err
	}
	v.latestVersion = tag
	return nil
}
func (v *ServiceImpl) vrsCompare(v1, v2 []int) (int, error) {
	compare := 0
	for i := 0; i < len(v1) && i < len(v2); i++ {
		if v1[i] < v2[i] {
			compare = -1
			break
		}
		if v1[i] > v2[i] {
			compare = 1
			break
		}
	}
	return compare, nil
}
func (v *ServiceImpl) versionAtMost(versionAtMostArg, max []int) (bool, error) {
	if comp, err := v.vrsCompare(versionAtMostArg, max); err != nil {
		return false, err
	} else if comp == 1 {
		return false, nil
	}
	return true, nil
}
func (v *ServiceImpl) parseVersion(versionToParse string) []int {
	if versionToParse == "" {
		return nil
	}
	if strings.Contains(versionToParse, "-") {
		versionToParse = strings.Split(versionToParse, "-")[0]
	}
	if strings.Contains(versionToParse, "v") {
		versionToParse = strings.TrimPrefix(versionToParse, "v")
	}
	parts := strings.Split(versionToParse, ".")
	parsedVersion := make([]int, len(parts))
	for i, part := range parts {
		if num, err := strconv.Atoi(part); err != nil {
			return nil
		} else {
			parsedVersion[i] = num
		}
	}
	return parsedVersion
}
func (v *ServiceImpl) IsLatestVersion() (bool, error) {
	if info.IsPrivate() {
		return false, fmt.Errorf("cannot check version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return false, err
		}
	}

	currentVersionParts := v.parseVersion(v.currentVersion)
	latestVersionParts := v.parseVersion(v.latestVersion)

	if len(currentVersionParts) == 0 || len(latestVersionParts) == 0 {
		return false, fmt.Errorf("invalid version format")
	}

	if len(currentVersionParts) != len(latestVersionParts) {
		return false, fmt.Errorf("version parts length mismatch")
	}

	return v.versionAtMost(currentVersionParts, latestVersionParts)
}
func (v *ServiceImpl) GetLatestVersion() (string, error) {
	if info.IsPrivate() {
		return "", fmt.Errorf("cannot fetch latest version for private repositories")
	}
	if v.latestVersion == "" {
		if err := v.updateLatestVersion(); err != nil {
			return "", err
		}
	}
	return v.latestVersion, nil
}
func (v *ServiceImpl) GetCurrentVersion() string {
	if v.currentVersion == "" {
		v.currentVersion = info.GetVersion()
	}
	return v.currentVersion
}
func (v *ServiceImpl) GetName() string {
	if info == nil {
		return "Unknown Service"
	}
	return info.GetName()
}
func (v *ServiceImpl) GetVersion() string {
	if info == nil {
		return "Unknown version"
	}
	return info.GetVersion()
}
func (v *ServiceImpl) GetRepository() string {
	if info == nil {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func (v *ServiceImpl) setLastCheckedAt(t time.Time) {
	v.lastCheckedAt = t
	gl.Log("debug", "Last checked at: "+t.Format(time.RFC3339))
}

func NewVersionService() Service {
	return &ServiceImpl{
		Manifest:       info,
		gitModelURL:    info.GetRepository(),
		currentVersion: info.GetVersion(),
		latestVersion:  "",
	}
}

var (
	versionCmd   *cobra.Command
	subLatestCmd *cobra.Command
	subCmdCheck  *cobra.Command
	updCmd       *cobra.Command
	getCmd       *cobra.Command
	restartCmd   *cobra.Command
)

func init() {
	if versionCmd == nil {
		versionCmd = &cobra.Command{
			Use:   "version",
			Short: "Print the version number of " + info.GetName(),
			Long:  "Print the version number of " + info.GetName() + " and other related information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("warn", "The information shown may not be accurate for private repositories.")
					gl.Log("info", "Current version: "+GetVersion())
					gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
					return
				}
				GetVersionInfo()
			},
		}
	}
	if subLatestCmd == nil {
		subLatestCmd = &cobra.Command{
			Use:   "latest",
			Short: "Print the latest version number of " + info.GetName(),
			Long:  "Print the latest version number of " + info.GetName() + " from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot fetch latest version for private repositories.")
					return
				}
				GetLatestVersionInfo()
			},
		}
	}
	if subCmdCheck == nil {
		subCmdCheck = &cobra.Command{
			Use:   "check",
			Short: "Check if the current version is the latest version of " + info.GetName(),
			Long:  "Check if the current version is the latest version of " + info.GetName() + " and print the version information.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot check version for private repositories.")
					return
				}
				GetVersionInfoWithLatestAndCheck()
			},
		}
	}
	if updCmd == nil {
		updCmd = &cobra.Command{
			Use:   "update",
			Short: "Update the version information of " + info.GetName(),
			Long:  "Update the version information of " + info.GetName() + " by fetching the latest version from the Git repository.",
			Run: func(cmd *cobra.Command, args []string) {
				if info.IsPrivate() {
					gl.Log("error", "Cannot update version for private repositories.")
					return
				}
				if err := vrs.updateLatestVersion(); err != nil {
					gl.Log("error", "Failed to update version: "+err.Error())
				} else {
					latestVersion, err := vrs.GetLatestVersion()
					if err != nil {
						gl.Log("error", "Failed to get latest version: "+err.Error())
					} else {
						gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
						gl.Log("info", "Latest version: "+latestVersion)
					}
					vrs.setLastCheckedAt(time.Now())
				}
			},
		}
	}
	if getCmd == nil {
		getCmd = &cobra.Command{
			Use:   "get",
			Short: "Get the current version of " + info.GetName(),
			Long:  "Get the current version of " + info.GetName() + " from the manifest.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Current version: "+vrs.GetCurrentVersion())
			},
		}
	}
	if restartCmd == nil {
		restartCmd = &cobra.Command{
			Use:   "restart",
			Short: "Restart the " + info.GetName() + " service",
			Long:  "Restart the " + info.GetName() + " service to apply any changes made.",
			Run: func(cmd *cobra.Command, args []string) {
				gl.Log("info", "Restarting the service...")
				// Logic to restart the service can be added here
				gl.Log("success", "Service restarted successfully")
			},
		}
	}

}
func GetVersion() string {
	if info == nil {
		_, err := manifest.GetManifest()
		if err != nil {
			gl.Log("error", "Failed to get manifest: "+err.Error())
			return "Unknown version"
		}
	}
	return info.GetVersion()
}
func GetGitRepositoryModelURL() string {
	if info.GetRepository() == "" {
		return "No repository URL set in the manifest."
	}
	return info.GetRepository()
}
func GetVersionInfo() string {
	gl.Log("info", "Version: "+GetVersion())
	gl.Log("info", "Git repository: "+GetGitRepositoryModelURL())
	return fmt.Sprintf("Version: %s\nGit repository: %s", GetVersion(), GetGitRepositoryModelURL())
}
func GetLatestVersionFromGit() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}

	netClient := &http.Client{
		Timeout: time.Second * 10,
	}

	gitURLWithoutGit := strings.TrimSuffix(GetGitRepositoryModelURL(), ".git")
	if gitURLWithoutGit == "" {
		gl.Log("error", "No repository URL set in the manifest.")
		return "No repository URL set in the manifest."
	}

	response, err := netClient.Get(gitURLWithoutGit + "/releases/latest")
	if err != nil {
		gl.Log("error", "Error fetching latest version: "+err.Error())
		gl.Log("error", gitURLWithoutGit+"/releases/latest")
		return err.Error()
	}

	if response.StatusCode != 200 {
		gl.Log("error", "Error fetching latest version: "+response.Status)
		gl.Log("error", "Url: "+gitURLWithoutGit+"/releases/latest")
		body, _ := io.ReadAll(response.Body)
		return fmt.Sprintf("Error: %s\nResponse: %s", response.Status, string(body))
	}

	tag := strings.Split(response.Request.URL.Path, "/")

	return tag[len(tag)-1]
}
func GetLatestVersionInfo() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot fetch latest version for private repositories.")
		return "Cannot fetch latest version for private repositories."
	}
	gl.Log("info", "Latest version: "+GetLatestVersionFromGit())
	return "Latest version: " + GetLatestVersionFromGit()
}
func GetVersionInfoWithLatestAndCheck() string {
	if info.IsPrivate() {
		gl.Log("error", "Cannot check version for private repositories.")
		return "Cannot check version for private repositories."
	}
	if GetVersion() == GetLatestVersionFromGit() {
		gl.Log("info", "You are using the latest version.")
		return fmt.Sprintf("You are using the latest version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	} else {
		gl.Log("warn", "You are using an outdated version.")
		return fmt.Sprintf("You are using an outdated version.\n%s\n%s", GetVersionInfo(), GetLatestVersionInfo())
	}
}
func CliCommand() *cobra.Command {
	versionCmd.AddCommand(subLatestCmd)
	versionCmd.AddCommand(subCmdCheck)
	versionCmd.AddCommand(updCmd)
	versionCmd.AddCommand(getCmd)
	versionCmd.AddCommand(restartCmd)
	return versionCmd
}

/// internal/module/wrpr.go ///
package module

import (
	"os"
	"strings"
)

func RegX() *Ghbex {
	var printBannerV = os.Getenv("GHBEX_PRINT_BANNER")
	if printBannerV == "" {
		printBannerV = "true"
	}

	return &Ghbex{
		PrintBanner: strings.ToLower(printBannerV) == "true",
	}
}

/// internal/notify/discord.go ///
// Package notify provides functionality for sending notifications to various channels.
package notify

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/rafa-mori/ghbex/internal/sanitize"
)

type Discord struct {
	Webhook string
}

type Stdout struct{}

func (Stdout) Send(ctx context.Context, title, text string, files ...sanitize.Attachment) error {
	fmt.Printf("\n==== %s ====\n%s\n", title, text)
	return nil
}

func (d Discord) Send(ctx context.Context, title, text string, files ...sanitize.Attachment) error {
	if d.Webhook == "" {
		return nil
	}
	payload := map[string]any{
		"content": "**" + title + "**\n" + text,
	}
	b, _ := json.Marshal(payload)
	req, _ := http.NewRequestWithContext(ctx, "POST", d.Webhook, bytes.NewReader(b))
	req.Header.Set("Content-Type", "application/json")
	_, err := http.DefaultClient.Do(req)
	return err
}

/// internal/sanitize/gh_cleaners.go ///
package sanitize

import (
	"context"
	"slices"
	"time"

	"github.com/google/go-github/v61/github"
)

func cleanRuns(ctx context.Context, cli *github.Client, owner, repo string, r RunsRule, dry bool) (deleted, kept int, ids []int64, err error) {
	opt := &github.ListWorkflowRunsOptions{ListOptions: github.ListOptions{PerPage: 100}}
	cut := cutoff(r.MaxAgeDays)
	allow := func(name string) bool {
		if len(r.OnlyWorkflows) == 0 {
			return true
		}
		return slices.Contains(r.OnlyWorkflows, name)
	}

	for {
		rs, resp, e := cli.Actions.ListRepositoryWorkflowRuns(ctx, owner, repo, opt)
		if e != nil {
			err = e
			return
		}
		for _, run := range rs.WorkflowRuns {
			if !allow(run.GetName()) {
				continue
			}
			ids = append(ids, run.GetID())

			// keep N latest successful
			if run.GetStatus() == "completed" && run.GetConclusion() == "success" && kept < r.KeepSuccessLast {
				kept++
				continue
			}
			// age filter
			if !cut.IsZero() && run.GetCreatedAt().Time.After(cut) {
				continue
			}
			if dry {
				deleted++
				continue
			}
			if e := deleteRun(ctx, cli, owner, repo, run.GetID()); e == nil {
				deleted++
			}
			if resp.NextPage == 0 {
				break
			}
			opt.Page = resp.NextPage
		}

		return
	}
}

func deleteRun(ctx context.Context, cli *github.Client, owner, repo string, id int64) error {
	_, err := cli.Actions.DeleteWorkflowRun(ctx, owner, repo, id)
	return err
}

func cleanArtifacts(ctx context.Context, cli *github.Client, owner, repo string, r ArtifactsRule, dry bool) (deleted int, ids []int64, err error) {
	cut := cutoff(r.MaxAgeDays)
	opt := &github.ListOptions{PerPage: 100}
	for {
		arts, resp, e := cli.Actions.ListArtifacts(ctx, owner, repo, opt)
		if e != nil {
			err = e
			return
		}
		for _, a := range arts.Artifacts {
			ids = append(ids, a.GetID())
			if cut.IsZero() || a.GetCreatedAt().Time.Before(cut) {
				if dry {
					deleted++
					continue
				}
				if e := deleteArtifact(ctx, cli, owner, repo, a.GetID()); e == nil {
					deleted++
				}
			}
			if resp.NextPage == 0 {
				break
			}
			opt.Page = resp.NextPage
		}
	}
}

func deleteArtifact(ctx context.Context, cli *github.Client, owner, repo string, id int64) error {
	_, err := cli.Actions.DeleteArtifact(ctx, owner, repo, id)
	return err
}

func cleanReleases(ctx context.Context, cli *github.Client, owner, repo string, r ReleasesRule, dry bool) (deletedDrafts int, tags []string, err error) {
	opt := &github.ListOptions{PerPage: 100}
	for {
		rel, resp, e := cli.Repositories.ListReleases(ctx, owner, repo, opt)
		if e != nil {
			err = e
			return
		}
		for _, rr := range rel {
			if rr.GetDraft() && r.DeleteDrafts {
				if dry {
					deletedDrafts++
					continue
				}
				if e := deleteRelease(ctx, cli, owner, repo, rr.GetID()); e == nil {
					deletedDrafts++
				}
			}
			if rr.TagName != nil {
				tags = append(tags, rr.GetTagName())
			}
			if resp.NextPage == 0 {
				break
			}
			opt.Page = resp.NextPage
		}
	}
}

func deleteRelease(ctx context.Context, cli *github.Client, owner, repo string, id int64) error {
	_, err := cli.Repositories.DeleteRelease(ctx, owner, repo, id)
	return err
}

func cutoff(days int) time.Time {
	if days <= 0 {
		return time.Time{}
	}
	return time.Now().AddDate(0, 0, -days)
}

/// internal/sanitize/service.go ///
package sanitize

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/google/go-github/v61/github"
)

type Notifier interface {
	Send(ctx context.Context, title, text string, files ...Attachment) error
}
type Attachment struct {
	Name string
	Body []byte
}

type Service struct {
	cli       *github.Client
	cfg       Config
	notifiers []Notifier
}

func New(cli *github.Client, cfg Config, ntf ...Notifier) *Service {
	return &Service{cli: cli, cfg: cfg, notifiers: ntf}
}

type Report struct {
	Owner  string    `json:"owner"`
	Repo   string    `json:"repo"`
	When   time.Time `json:"when"`
	DryRun bool      `json:"dry_run"`

	Runs struct {
		Deleted int     `json:"deleted"`
		Kept    int     `json:"kept"`
		IDs     []int64 `json:"ids"`
	} `json:"runs"`

	Artifacts struct {
		Deleted int     `json:"deleted"`
		IDs     []int64 `json:"ids"`
	} `json:"artifacts"`

	Releases struct {
		DeletedDrafts int      `json:"deleted_drafts"`
		Tags          []string `json:"tags"`
	} `json:"releases"`

	Notes []string `json:"notes"`
}

func (s *Service) SanitizeRepo(ctx context.Context, owner, repo string, rules Rules, dryRun bool) (*Report, error) {
	rpt := &Report{Owner: owner, Repo: repo, When: time.Now(), DryRun: dryRun}

	d1, k1, ids1, err := cleanRuns(ctx, s.cli, owner, repo, rules.Runs, dryRun)
	if err != nil {
		rpt.Notes = append(rpt.Notes, "runs: "+err.Error())
	}
	rpt.Runs.Deleted, rpt.Runs.Kept, rpt.Runs.IDs = d1, k1, ids1

	d2, ids2, err := cleanArtifacts(ctx, s.cli, owner, repo, rules.Artifacts, dryRun)
	if err != nil {
		rpt.Notes = append(rpt.Notes, "artifacts: "+err.Error())
	}
	rpt.Artifacts.Deleted, rpt.Artifacts.IDs = d2, ids2

	d3, tags, err := cleanReleases(ctx, s.cli, owner, repo, rules.Releases, dryRun)
	if err != nil {
		rpt.Notes = append(rpt.Notes, "releases: "+err.Error())
	}
	rpt.Releases.DeletedDrafts, rpt.Releases.Tags = d3, tags

	// persist report
	dir := filepath.Join(s.cfg.Runtime.ReportDir, time.Now().Format("2006-01-02"))
	_ = os.MkdirAll(dir, 0o755)

	jb, _ := json.MarshalIndent(rpt, "", "  ")
	md := toMarkdown(rpt)
	_ = os.WriteFile(filepath.Join(dir, fmt.Sprintf("%s_%s.json", owner, repo)), jb, 0o644)
	_ = os.WriteFile(filepath.Join(dir, fmt.Sprintf("%s_%s.md", owner, repo)), []byte(md), 0o644)

	// notify
	title := fmt.Sprintf("Repo sanitize: %s/%s (dry_run=%v)", owner, repo, dryRun)
	for _, n := range s.notifiers {
		_ = n.Send(ctx, title, md,
			Attachment{Name: "report.json", Body: jb},
			Attachment{Name: "report.md", Body: []byte(md)},
		)
	}
	return rpt, nil

}

func toMarkdown(r *Report) string {
	return fmt.Sprintf(`# Sanitize %s/%s
- when: %s
- dry_run: %v

## runs
- deleted: %d
- kept(success last): %d

## artifacts
- deleted: %d

## releases
- deleted drafts: %d
- tags: %v

notes:
%v
`,
		r.Owner, r.Repo, r.When.Format(time.RFC3339), r.DryRun,
		r.Runs.Deleted, r.Runs.Kept,
		r.Artifacts.Deleted,
		r.Releases.DeletedDrafts, r.Releases.Tags,
		r.Notes,
	)
}

/// internal/sanitize/types.go ///
// Package sanitize defines the configuration types used for sanitizing GitHub repositories.
package sanitize

type RunsRule struct {
	MaxAgeDays      int      `yaml:"max_age_days"`
	KeepSuccessLast int      `yaml:"keep_success_last"`
	OnlyWorkflows   []string `yaml:"only_workflows"`
}
type ArtifactsRule struct {
	MaxAgeDays int `yaml:"max_age_days"`
}
type ReleasesRule struct {
	DeleteDrafts bool `yaml:"delete_drafts"`
}

type Rules struct {
	Runs      RunsRule      `yaml:"runs"`
	Artifacts ArtifactsRule `yaml:"artifacts"`
	Releases  ReleasesRule  `yaml:"releases"`
}

type RepoCfg struct {
	Owner string `yaml:"owner"`
	Name  string `yaml:"name"`
	Rules Rules  `yaml:"rules"`
}

type Config struct {
	Runtime struct {
		DryRun    bool   `yaml:"dry_run"`
		ReportDir string `yaml:"report_dir"`
	} `yaml:"runtime"`
	GitHub struct {
		Repos []RepoCfg `yaml:"repos"`
	} `yaml:"github"`
}

/// support/gox_mod_final.sh ///
#!/usr/bin/env bash

# gox_mod.sh — modular, robust and "publishable" Go build
# License: MIT (add LICENSE to repo if desired)
# Requirements: bash 4+, Go 1.18+ (recommended), git

set -o errexit
set -o errtrace
set -o functrace
set -o nounset
set -o pipefail
shopt -s inherit_errexit

IFS=$'\n\t'

# ====== Defaults (override via ENV or flags) ======
: "${DIST_DIR:=dist}"
: "${MAKE_TARGET:=build-dev}"
: "${ENABLE_UPX:=0}"                 # 1 to compress with upx
: "${DEFAULT_OS:=}"                  # e.g.: linux
: "${DEFAULT_ARCH:=}"                # e.g.: amd64
: "${BUILD_TAGS:=}"                  # e.g.: netgo,osusergo
: "${ENABLE_RACE:=0}"                # -race on host
: "${VERBOSE:=0}"                    # -v, --verbose
: "${DEBUG:=0}"                      # -x
: "${LD_EXTRA:=}"                    # user extra ldflags

# If BUILDINFO_PATH='main' (or 'mod/internal/buildinfo'),
# injects -X <path>.Version/.Commit/.BuildDate with git info.
: "${BUILDINFO_PATH:=}"

# ====== Utils ======
# Color codes for logs
_SUCCESS="\033[0;32m"
_WARN="\033[0;33m"
_ERROR="\033[0;31m"
_INFO="\033[0;36m"
_NOTICE="\033[0;35m"
_NC="\033[0m"

clear_screen() {
  printf "\033[H\033[2J"
}
now_ms() {
  if command -v gdate >/dev/null 2>&1; then
    # coreutils (brew install coreutils)
    gdate +%s%3N
  elif command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
  elif command -v perl >/dev/null 2>&1; then
    perl -MTime::HiRes=time -e 'printf("%d\n", time()*1000)'
  elif command -v ruby >/dev/null 2>&1; then
    ruby -e 'puts (Time.now.to_f*1000).to_i'
  elif command -v node >/dev/null 2>&1; then
    node -e 'console.log(Date.now())'
  else
    # fallback aproximado (segundos -> ms)
    echo "$(( $(date +%s) * 1000 ))"
  fi
}
log() {
  local type="${1:-}"
  local message="${2:-}"
  local verbose="${3:-${VERBOSE:-0}}"
  verbose="${verbose:-${DEBUG:-0}}"

  case $type in
    question|_QUESTION|-q|-Q)
      if (( verbose )) || (( DEBUG )); then
        printf '%b[QUESTION]%b - %s - ❓  %s: ' "$_NOTICE" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      fi
      ;;
    notice|_NOTICE|-n|-N)
      if (( verbose )) || (( DEBUG )); then
        printf '%b[NOTICE]%b - %s - 📝  %s\n' "$_NOTICE" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      fi
      ;;
    info|_INFO|-i|-I)
      if (( verbose )) || (( DEBUG )); then
        printf '%b[INFO]%b - %s - ℹ️  %s\n' "$_INFO" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      fi
      ;;
    warn|_WARN|-w|-W)
      if (( verbose )) || (( DEBUG )); then
        printf '%b[WARN]%b - %s - ⚠️  %s\n' "$_WARN" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      fi
      ;;
    error|_ERROR|-e|-E)
      printf '%b[ERROR]%b - %s - ❌  %s\n' "$_ERROR" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      ;;
    success|_SUCCESS|-s|-S)
      printf '%b[SUCCESS]%b - %s - ✅  %s\n' "$_SUCCESS" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      ;;
    fatal|_FATAL|-f|-F)
      printf '%b[FATAL]%b 💀 - %s - %s\n' "$_FATAL" "$_NC" "$(date +%H:%M:%S)" "$message" >&2
      if (( verbose )) || (( DEBUG )); then
        printf '%b[FATAL]%b 💀  %s\n' "$_FATAL" "$_NC" "Exiting due to fatal error." >&2
      fi
      # clear_build_artifacts
      exit 1
      ;;
    *)
      if (( verbose )) || (( DEBUG )); then
        log "info" "$message" "$verbose"
      fi
      ;;
  esac
  return 0
}
die()  { log fatal "$*"; }
have() { command -v "${1:-}" >/dev/null 2>&1; }

usage() {

  cat <<'EOF'
Usage: ./gox_mod.sh [options] [PATH]

Options:
--all                   Build for default matrix (linux,darwin,windows x amd64,arm64)
--os OS1,OS2            List of GOOS (e.g.: linux,darwin)
--arch A1,A2            List of GOARCH (e.g.: amd64,arm64)
--tags TAGS             Build tags (e.g.: 'netgo,osusergo')
--race                  Enables -race on native build
--upx                   Compress with UPX (if installed)
-d, --debug             Debug mode (set -x)
-v, --verbose           Verbose (-v)
-h, --help              Help

Environment:
DIST_DIR, MAKE_TARGET, ENABLE_UPX, DEFAULT_OS, DEFAULT_ARCH,
BUILD_TAGS, ENABLE_RACE, VERBOSE, LD_EXTRA, BUILDINFO_PATH

Examples:
./gox_mod.sh
./gox_mod.sh --all
./gox_mod.sh --os linux --arch arm64 ./cmd/myapp
BUILDINFO_PATH=main LD_EXTRA="-s -w" ./gox_mod.sh
EOF

}

_START_TIME="$(now_ms)"

# ====== Args ======
ALL=0
declare -A GOPLT_MAP=()
declare -a ARG_GOOS_LIST=()
declare -a ARG_GOARCH_LIST=()
TARGET_PATH=""

# shellcheck disable=SC2015
parse_args() {
  while (("$#")); do
    case "${1:-}" in
      --all) ALL=1 ;;
      --os) shift; IFS=',' read -r -a ARG_GOOS_LIST <<< "${1:-}";;
      --arch) shift; IFS=',' read -r -a ARG_GOARCH_LIST <<< "${1:-}";;
      --tags) shift; BUILD_TAGS="${1:-}";;
      --race) ENABLE_RACE=1 ;;
      --upx) ENABLE_UPX=1 ;;
      -d|--debug) DEBUG=1;;
      -v|--verbose) VERBOSE=1 ;;
      -h|--help) usage; exit 0 ;;
      *) TARGET_PATH="${1:-}";;
    esac
    shift || true
  done
  (( DEBUG )) && set -x || true
  (( VERBOSE )) && set -v || true
}

# ====== Project / module / git ======
PROJECT_ROOT=""
MOD_NAME=""
GIT_TAG=""
GIT_COMMIT=""
GIT_DATE=""

detect_project_root() {
  PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
  cd "${PROJECT_ROOT}"
}

read_module_name() {
  if [[ -f go.mod ]]; then
    MOD_NAME="$(awk '/^module /{print $2}' go.mod | awk -F'/' '{print $NF}')"
  fi
  [[ -n "${MOD_NAME}" ]] || MOD_NAME="$(basename "${PROJECT_ROOT}")"
}

git_info() {
  if have git && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    GIT_TAG="$(git describe --tags --dirty --always 2>/dev/null || true)"
    GIT_COMMIT="$(git rev-parse --short HEAD 2>/dev/null || true)"
    GIT_DATE="$(git show -s --format=%cd --date=format:%Y-%m-%d 2>/dev/null || date +%Y-%m-%d)"
    SOURCE_DATE_EPOCH="$(git log -1 --pretty=%ct 2>/dev/null || date +%s)"; export SOURCE_DATE_EPOCH
  else
    GIT_TAG="dev"; GIT_COMMIT="none"; GIT_DATE="$(date +%Y-%m-%d)"
    SOURCE_DATE_EPOCH="$(date +%s)"; export SOURCE_DATE_EPOCH
  fi
}

# ====== Discover 'main' packages ======
discover_mains() {
  local path="./..."
  if [[ -n "${TARGET_PATH}" ]]; then
    local rp; rp="$(realpath "${TARGET_PATH}")"
    if [[ -d "${rp}" ]]; then
      path="${rp}/..."
    else
      path="$(dirname "${rp}")/..."
    fi
  fi
  mapfile -t MAIN_DIRS < <(go list -f '{{if eq .Name "main"}}{{.Dir}}{{end}}' "${path}" | awk 'NF')
  (( ${#MAIN_DIRS[@]} )) || die "No 'main' package found."
}

# ====== GOOS/GOARCH Matrix ======
compute_matrix() {
  if (( ALL )); then
    GOPLT_MAP[linux]="(amd64)"
    GOPLT_MAP[darwin]="(amd64 arm64)"
    GOPLT_MAP[windows]="(amd64 386)"
    ARG_GOOS_LIST=(linux darwin windows)
    ARG_GOARCH_LIST=(amd64 arm64 386)
    return 0
  fi
  if [[ ${#ARG_GOOS_LIST[@]} -eq 0 ]]; then
    # shellcheck disable=SC2207
    if [[ -n "${DEFAULT_OS}" ]]; then
      ARG_GOOS_LIST=("${DEFAULT_OS}");
      for _GOENVOS in "${ARG_GOOS_LIST[@]}"; do
        GOPLT_MAP["${_GOENVOS}"]="(amd64)";
      done
    else
      ARG_GOOS_LIST=( $(go env GOOS) );
      for os in "${!ARG_GOOS_LIST[@]}"; do
        GOPLT_MAP[${ARG_GOOS_LIST[$os]}]="( $(go env GOARCH || echo amd64) )";
      done
    fi
  fi
  if [[ ${#ARG_GOARCH_LIST[@]} -eq 0 ]]; then
    # shellcheck disable=SC2207
    if [[ -n "${DEFAULT_ARCH}" ]]; then
      ARG_GOARCH_LIST=("${DEFAULT_ARCH}");
      for _GOENVARCH in "${ARG_GOARCH_LIST[@]}"; do
        for os in "${!ARG_GOOS_LIST[@]}"; do
          if [[ -z "${GOPLT_MAP[${ARG_GOOS_LIST[${os:-}]}]}" ]]; then
            GOPLT_MAP["${ARG_GOOS_LIST[${os:-}]}"]="(${_GOENVARCH})";
          else
            if ! [[ " ${GOPLT_MAP[${ARG_GOOS_LIST[${os:-}]}]} " == *" ${_GOENVARCH} "* ]]; then
              GOPLT_MAP["${ARG_GOOS_LIST[${os:-}]}"]+=" ${_GOENVARCH}";
            fi
          fi
        done
      done
    else
      ARG_GOARCH_LIST=( $(go env GOARCH) );
      for _GOENVARCH in "${ARG_GOARCH_LIST[@]}"; do
        for os in "${!ARG_GOOS_LIST[@]}"; do
          if [[ -z "${GOPLT_MAP[${ARG_GOOS_LIST[${os:-}]}]}" ]]; then
            GOPLT_MAP["${ARG_GOOS_LIST[${os:-}]}"]="(${_GOENVARCH})";
          else
            if ! [[ " ${GOPLT_MAP[${ARG_GOOS_LIST[${os:-}]}]} " == *" ${_GOENVARCH} "* ]]; then
              GOPLT_MAP["${ARG_GOOS_LIST[${os:-}]}"]+=" ${_GOENVARCH}";
            fi
          fi
        done
      done
    fi
  fi
}

# ====== Detect build flag support ======
supports_build_flag() {
  # e.g.: supports_build_flag buildvcs
  go help build 2>/dev/null | grep -q -- "-$1\b"
}

# ====== Build argument assembly ======
declare -a BUILD_ARGS=()

build_flags() {
  local os="${1:-}"
  local arch="${2:-}"
  BUILD_ARGS=()  # reset

  if supports_build_flag trimpath; then
    BUILD_ARGS+=(-trimpath)
  fi
  if supports_build_flag buildvcs; then
    BUILD_ARGS+=(-buildvcs)
  fi

  if (( ENABLE_RACE )); then
    local host_os;   host_os="$(uname -s | tr '[:upper:]' '[:lower:]')"
    local host_arch; host_arch="$(uname -m)"
    if [[ "$os" == "$host_os" && "$arch" == "$host_arch" ]]; then
      BUILD_ARGS+=(-race)
    fi
  fi

  if [[ -n "${BUILD_TAGS}" ]]; then
    BUILD_ARGS+=(-tags "${BUILD_TAGS}")
  fi

  local ld_str="-s -w"
  [[ -n "${LD_EXTRA}" ]] && ld_str="${ld_str} ${LD_EXTRA}"
  if [[ -n "${BUILDINFO_PATH}" ]]; then
    ld_str="${ld_str} -X ${BUILDINFO_PATH}.Version=${GIT_TAG}"
    ld_str="${ld_str} -X ${BUILDINFO_PATH}.Commit=${GIT_COMMIT}"
    ld_str="${ld_str} -X ${BUILDINFO_PATH}.BuildDate=${GIT_DATE}"
  fi
  BUILD_ARGS+=(-ldflags "${ld_str}")
}

# ====== UPX ======
maybe_upx() {
  local bin="${1:-}"
  (( ENABLE_UPX )) || return 0
  have upx || { log warn "UPX not found; continuing without compression."; return 0; }
  log notice "UPX: compressing '${bin}'"
  upx "$bin" --force-overwrite --lzma --no-progress --no-color -qqq || log info "UPX failed (ignoring)."
}

# ====== Build ======
build_one() {
  local _dir="${1:-.}"
  local _os="${2:-$(uname -s | tr '[:upper:]' '[:lower:]')}"
  local _arch="${3:-$(uname -m)}"
  local _ext="";
  [[ "${_os}" == "windows" ]] && _ext=".exe"

  local _pkg_name;
  _pkg_name="$(basename "${_dir}")"

  local _bin_name="${MOD_NAME}_${_os}_${_arch}${_ext:-}"
  local _out_dir="${DIST_DIR}" # /${_pkg_name}"

  mkdir -p "${_out_dir}"

  local _out_bin="${_out_dir}/${_bin_name}"

  log info "Building ${_pkg_name} -> ${_out_bin}"
  build_flags "${_os}" "${_arch}"

  GOOS="${_os}" GOARCH="${_arch}" \
  go mod tidy > /dev/null || {
    log warn "go mod tidy failed (ignoring)."
    return 1
  }
  GOOS="${_os}" GOARCH="${_arch}" \
  go build \
  "${BUILD_ARGS[@]}" \
  -o "${_out_bin}" "${_dir}"

  maybe_upx "${_out_bin}"
  log success "OK: ${_out_bin}"
}

build_all() {
  mkdir -p "${DIST_DIR}"

  if [[ -f Makefile ]]; then
    log info "Makefile detected. Running target '${MAKE_TARGET}'..."
    # shellcheck disable=SC1007
    if MAKEFLAGS= FORCE=y make "${MAKE_TARGET}"; then
      log success "Build via Makefile completed."
      return 0
    else
      log error "Target '${MAKE_TARGET}' failed. Fallback to 'go build'."
    fi
  fi

  for __os in "${!GOPLT_MAP[@]}"; do
    local arch_list
    GOPLT_MAP[$__os]=${GOPLT_MAP[${__os}]//\(/}
    GOPLT_MAP[${__os}]=${GOPLT_MAP[${__os}]//\)/}
    IFS=' ' read -r -a arch_list <<< "${GOPLT_MAP[${__os}]}"
    for __arch in "${arch_list[@]}"; do
      for __dir in "${MAIN_DIRS[@]}"; do
        build_one "${__dir}" "${__os}" "${__arch}"
      done
    done
  done
}

# ====== Performance measurement ======
measure_performance() {
  local _EXIT_CODE="$?"
  _EXIT_CODE="${_EXIT_CODE:-${1:-}}"
  _EXIT_CODE="${_EXIT_CODE:-0}"

  # Measure total duration in milliseconds
  _END_TIME="$(now_ms)"
  _DURATION=$(( _END_TIME - _START_TIME ))

  if (( _DURATION < 1000 )); then
    log notice "Total duration: ${_DURATION} ms"
  else
    log notice "Total duration: $(( _DURATION / 60000 )) min $(( (_DURATION / 1000) % 60 )) sec $(( _DURATION % 1000 )) ms"
  fi

  if (( _EXIT_CODE == 0 )); then
    log success "All builds succeeded."
  else
    log error "Builds completed with errors (exit code: ${_EXIT_CODE})."
  fi
}

# ====== Main ======
main() {
  parse_args "$@" || die "Error parsing arguments."
  have go || die "Go not found in PATH."
  detect_project_root || die "Could not detect project directory."
  read_module_name || die "Could not read module name."
  git_info || true
  discover_mains || die "Could not discover 'main' packages."
  compute_matrix || die "Error computing GOOS/GOARCH matrix."
  build_all || die "Build failed."
  measure_performance $? || true
  return 0
}

main "$@"

/// support/kubex_go_release.yaml ///
name: Kubex Go Dist CI

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      target_manifest:
        description: 'Path to the module manifest (e.g., internal/module/info/manifest.json)'
        required: false
        default: 'internal/module/info/manifest.json'
        type: string
      tag_name:
        description: 'Tag name for manual release (e.g., v1.0.0)'
        required: false
        type: string
      debug:
        description: 'Enable debug mode'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Enable dry run mode'
        required: false
        default: false
        type: boolean
      platforms:
        description: 'Override platforms (comma-separated, e.g., linux/amd64,windows/amd64)'
        required: false
        default: ''
        type: string

permissions:
  contents: write
  packages: write
  id-token: write

env:
  _TARGET_MANIFEST: ${{ github.event.inputs.target_manifest }}
  _DEBUG: ${{ github.event.inputs.debug }}
  _DRY_RUN: ${{ github.event.inputs.dry_run }}
  _PLATFORMS: ${{ github.event.inputs.platforms }}
  NON_INTERACTIVE: true
  FORCE: y
  CI: true

jobs:
  # ==========================================
  # JOB 1: Build All Platforms
  # ==========================================
  build:
    name: Cross-Platform Build
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      go-version: ${{ steps.go-setup.outputs.go-version }}
      module-name: ${{ steps.manifest.outputs.module-name }}
      platforms: ${{ steps.manifest.outputs.platforms }}
      version-mismatch: ${{ steps.version-check.outputs.version-mismatch }}
      continue: ${{ steps.version-check.outputs.continue }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load Module Manifest
        id: manifest
        run: |
          if [[ ! -f "$(git rev-parse --show-toplevel)${{ github.env._TARGET_MANIFEST }}" ]]; then
            echo "❌ ${{ github.env._TARGET_MANIFEST }} not found"
            exit 1
          fi

          # Extract module information
          MODULE_NAME=$(cat $(git rev-parse --show-toplevel)${{ github.env._TARGET_MANIFEST }} | jq -r '.bin // .name // "unknown"')
          MODULE_VERSION=$(cat $(git rev-parse --show-toplevel)${{ github.env._TARGET_MANIFEST }} | jq -r '.version // "0.0.0"')
          PLATFORMS=$(cat $(git rev-parse --show-toplevel)${{ github.env._TARGET_MANIFEST }} | jq -r '.platforms[]?' | tr '\n' ' ' | sed 's/ $//')

          # Validate required fields
          if [[ "$MODULE_NAME" == "unknown" || "$MODULE_NAME" == "null" ]]; then
            echo "❌ Module name not found in manifest (bin or name field required)"
            exit 1
          fi

          if [[ -z "$PLATFORMS" ]]; then
            echo "❌ No platforms specified in manifest"
            exit 1
          fi

          echo "module-name=$MODULE_NAME" >> $GITHUB_OUTPUT
          echo "manifest-version=$MODULE_VERSION" >> $GITHUB_OUTPUT
          echo "platforms=$PLATFORMS" >> $GITHUB_OUTPUT

          echo "✅ Module: $MODULE_NAME"
          echo "✅ Manifest Version: $MODULE_VERSION"
          echo "✅ Platforms: $PLATFORMS"

      - name: Extract Version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.tag_name }}" ]]; then
            echo "version=${{ github.event.inputs.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: 🔍 Validate Tag Format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid version format: $VERSION"
            echo "Expected format: vX.Y.Z (e.g., v1.2.3)"
            exit 1
          fi
          echo "✅ Valid version: $VERSION"

      - name: Version Compatibility Check
        id: version-check
        run: |
          TAG_VERSION="${{ steps.version.outputs.version }}"
          MANIFEST_VERSION="v${{ steps.manifest.outputs.manifest-version }}"

          # Remove 'v' prefix for comparison
          TAG_CLEAN="${TAG_VERSION#v}"
          MANIFEST_CLEAN="${MANIFEST_VERSION#v}"

          echo "🏷️  Tag Version: $TAG_VERSION ($TAG_CLEAN)"
          echo "📋 Manifest Version: $MANIFEST_VERSION ($MANIFEST_CLEAN)"

          if [[ "$TAG_CLEAN" != "$MANIFEST_CLEAN" ]]; then
            echo ""
            echo "❌ Version Mismatch!"
            echo "   Git Tag: $TAG_VERSION"
            echo "   Manifest: $MANIFEST_VERSION"
            echo ""
            echo "Please update ${{ github.env._TARGET_MANIFEST }} version to match the git tag."
            echo "Expected: \"version\": \"$TAG_CLEAN\""
            echo ""
            echo "🛑 Workflow will skip remaining steps for safety."
            echo "version-mismatch=true" >> $GITHUB_OUTPUT
            echo "continue=false" >> $GITHUB_OUTPUT
          else
            echo "✅ Version compatibility confirmed: $TAG_VERSION"
            echo "version-mismatch=false" >> $GITHUB_OUTPUT
            echo "continue=true" >> $GITHUB_OUTPUT
          fi

      - name: Smart Go Setup
        id: go-setup
        if: steps.version-check.outputs.continue == 'true'
        run: |
          GO_VERSION=$(grep '^go ' $(git rev-parse --show-toplevel)/go.mod | awk '{print $2}')

          bash -c "$(curl -sSfL 'https://raw.githubusercontent.com/rafa-mori/gosetup/main/go.sh')" -s --version "$GO_VERSION"

          # Verify installation
          go version

          # Output for other jobs
          echo "go-version=$GO_VERSION" >> $GITHUB_OUTPUT

      - name: Cache Go Modules
        if: steps.version-check.outputs.continue == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ steps.go-setup.outputs.go-version }}-${{ hashFiles('**/go.sum', '**/go.mod') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ steps.go-setup.outputs.go-version }}-

      - name: Cross-Platform Build
        if: steps.version-check.outputs.continue == 'true'
        run: |
          MODULE_NAME="${{ steps.manifest.outputs.module-name }}"
          PLATFORMS="${{ steps.manifest.outputs.platforms }}"

          echo "Building $MODULE_NAME for platforms: $PLATFORMS"
          ENV_PLATFORMS="${ENV_PLATFORMS:-${{ github.event.inputs.platforms }}}"

          if [[ -z $ENV_PLATFORMS ]]; then
            echo "No platforms specified, using default from manifest."
          else
            PLATFORMS="$ENV_PLATFORMS"
          fi

          for platform in $PLATFORMS; do
            # Parse platform (format: os/arch or os-arch)
            if [[ "$platform" == *"/"* ]]; then
              OS=$(echo "$platform" | cut -d'/' -f1)
              ARCH=$(echo "$platform" | cut -d'/' -f2)
            elif [[ "$platform" == *"-"* ]]; then
              OS=$(echo "$platform" | cut -d'-' -f1)
              ARCH=$(echo "$platform" | cut -d'-' -f2)
            else
              echo "❌ Invalid platform format: $platform (expected: os/arch or os-arch)"
              continue
            fi

            # Set environment variables
            export NON_INTERACTIVE=${NON_INTERACTIVE:-${{ github.env.NON_INTERACTIVE }}}
            export FORCE=${FORCE:-${{ github.env.FORCE }}}
            export CI=${CI:-${{ github.env.CI }}}
            export DRY_RUN=${DRY_RUN:-${{ github.event.inputs.dry_run }}}
            export DEBUG=${DEBUG:-${{ github.event.inputs.debug }}}

            echo "🔨 Building for $OS/$ARCH..."
            make build "${OS:-}" "${ARCH:-}"
          done

      - name: Verify Build Artifacts
        if: steps.version-check.outputs.continue == 'true'
        run: |
          MODULE_NAME="${{ steps.manifest.outputs.module-name }}"
          PLATFORM_LIST="${{ steps.manifest.outputs.platforms }}"
          ARTIFACT_LIST=()

          for platform in $PLATFORM_LIST; do
            # Parse platform (format: os/arch or os-arch)
            if [[ "$platform" == *"/"* ]]; then
              OS=$(echo "$platform" | cut -d'/' -f1)
              ARCH=$(echo "$platform" | cut -d'/' -f2)
            elif [[ "$platform" == *"-"* ]]; then
              OS=$(echo "$platform" | cut -d'-' -f1)
              ARCH=$(echo "$platform" | cut -d'-' -f2)
            else
              echo "❌ Invalid platform format: $platform (expected: os/arch or os-arch)"
              continue
            fi

            echo "os=${OS:-}" >> $GITHUB_OUTPUT
            echo "arch=${ARCH:-}" >> $GITHUB_OUTPUT

            if [[ ! $(basename pwd) != "bin" ]]; then
              ls -la $(git rev-parse --show-toplevel)/bin/
              cd $(git rev-parse --show-toplevel)/bin || exit 1
            fi

            ARTIFACT_LIST+=("${MODULE_NAME:-}_${OS:-}_${ARCH:-}")
          done

          cd $(git rev-parse --show-toplevel)/ || exit 1

          echo "ARTIFACT_LIST=${ARTIFACT_LIST[*]}" >> $GITHUB_OUTPUT
          echo "ARTIFACT_COUNT=${#ARTIFACT_LIST[@]}" >> $GITHUB_OUTPUT
          echo "ARTIFACTS_DIR=$(git rev-parse --show-toplevel)/bin" >> $GITHUB_OUTPUT

          if [[ ${#ARTIFACT_LIST[@]} -eq 0 ]]; then
            echo "❌ No build artifacts found!"
            exit 1
          else
            echo "✅ Build artifacts verified: ${ARTIFACT_LIST[*]}"
          fi

          if [[ ! -f $(git rev-parse --show-toplevel)/bin/SHA256SUMS ]]; then
            touch $(git rev-parse --show-toplevel)/bin/SHA256SUMS
          fi

          sha256sum $(git rev-parse --show-toplevel)/bin/* > $(git rev-parse --show-toplevel)/bin/SHA256SUMS

          ls -la $(git rev-parse --show-toplevel)/bin/

      - name: Upload Build Artifacts
        if: steps.version-check.outputs.continue == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.manifest.outputs.module-name }}-release-binaries
          path: |
            bin/${{ steps.manifest.outputs.module-name }}_*
          retention-days: 30

      - name: Version Mismatch Summary
        if: steps.version-check.outputs.version-mismatch == 'true'
        run: |
          echo "## ⚠️ Workflow Skipped Due to Version Mismatch" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Git Tag**: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Manifest**: v${{ steps.manifest.outputs.manifest-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please update \`info/manifest.json\` version to match the git tag before releasing." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Expected change in manifest:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
          echo "\"version\": \"${{ steps.version.outputs.version }}\"" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # JOB 2: Security Scan (Optional)
  # ==========================================
  # security:
  #   name: Security Scan
  #   runs-on: ubuntu-latest
  #   needs: build
  #   if: github.event_name != 'workflow_dispatch' && needs.build.outputs.continue == 'true'

  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v4

  #     - name: Smart Go Setup
  #       run: |
  #         GO_VERSION=$(grep '^go ' $(git rev-parse --show-toplevel)/go.mod | awk '{print $2}')

  #         bash -c "$(curl -sSfL 'https://raw.githubusercontent.com/rafa-mori/gosetup/main/go.sh')" -s --version "${GO_VERSION:-1.24.5}"

  #         # Verify installation
  #         go version

  #     - name: Restore Go Cache
  #       uses: actions/cache@v4
  #       with:
  #         path: |
  #           ~/.cache/go-build
  #           ~/go/pkg/mod
  #         key: ${{ runner.os }}-go-${{ needs.build.outputs.go-version }}-${{ hashFiles('**/go.sum', '**/go.mod') }}

  #     - name: Run Gosec Security Scanner
  #       run: |
  #         go install github.com/securego/gosec/v2/cmd/gosec@latest
  #         gosec -no-fail -fmt sarif -out gosec.sarif ./...

  #     - name: Upload SARIF file
  #       if: always()
  #       uses: github/codeql-action/upload-sarif@v3
  #       with:
  #         sarif_file: gosec.sarif

  # ==========================================
  # JOB 3: Create GitHub Release
  # ==========================================
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success' && needs.build.outputs.continue == 'true'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.module-name }}-release-binaries
          path: ./release-assets

      - name: Generate Release Notes
        run: |
          MODULE_NAME="${{ needs.build.outputs.module-name }}"
          VERSION="${{ needs.build.outputs.version }}"
          PLATFORMS="${{ needs.build.outputs.platforms }}"

          # Convert platforms to readable format
          PLATFORM_LIST=""
          for platform in $PLATFORMS; do
            if [[ "$platform" == *"/"* ]]; then
              OS=$(echo "$platform" | cut -d'/' -f1)
              ARCH=$(echo "$platform" | cut -d'/' -f2)
            elif [[ "$platform" == *"-"* ]]; then
              OS=$(echo "$platform" | cut -d'-' -f1)
              ARCH=$(echo "$platform" | cut -d'-' -f2)
            else
              echo "❌ Invalid platform format: $platform (expected: os/arch or os-arch)"
              continue
            fi

            # Add platform-specific information
            case "$platform" in
              "linux/amd64"|"linux-amd64") PLATFORM_LIST="$PLATFORM_LIST          - 🐧 **Linux (AMD64)**: \`${MODULE_NAME:-}_${OS:-}_${ARCH:-}.tar.gz\`" ;;
              "windows/amd64"|"windows-amd64") PLATFORM_LIST="$PLATFORM_LIST          - 🪟 **Windows (AMD64)**: \`${MODULE_NAME:-}_${OS:-}_${ARCH:-}.zip\`" ;;
              "windows/i386"|"windows-i386") PLATFORM_LIST="$PLATFORM_LIST          - 🪟 **Windows (i386)**: \`${MODULE_NAME:-}_${OS:-}_${ARCH:-}.zip\`" ;;
              "darwin/amd64"|"darwin-amd64") PLATFORM_LIST="$PLATFORM_LIST          - 🍎 **macOS (AMD64)**: \`${MODULE_NAME:-}_${OS:-}_${ARCH:-}.tar.gz\`" ;;
              "darwin/arm64"|"darwin-arm64") PLATFORM_LIST="$PLATFORM_LIST          - 🍎 **macOS (ARM64)**: \`${MODULE_NAME:-}_${OS:-}_${ARCH:-}.tar.gz\`" ;;
              *) PLATFORM_LIST="$PLATFORM_LIST          - 📦 **${platform:-}**: \`${MODULE_NAME:-}_${OS:-}_${ARCH:-}.tar.gz\`" ;;
            esac
          done

          cat > RELEASE_NOTES.md << EOF
          ## ${MODULE_NAME:-} Release ${VERSION:-}

          ### What's Included

          This release contains cross-platform binaries for:
          ${PLATFORM_LIST:-}

          ### Installation

          #### Linux/macOS
          \`\`\`bash
          # Download and extract
          wget https://github.com/${{ github.repository }}/releases/download/$VERSION/${MODULE_NAME}_linux_amd64.tar.gz
          tar -xzf ${MODULE_NAME:-}_linux_amd64.tar.gz
          chmod +x ${MODULE_NAME:-}_linux_amd64
          sudo mv ${MODULE_NAME:-}_linux_amd64 /usr/local/bin/${MODULE_NAME:-}
          \`\`\`

          #### Windows
          \`\`\`powershell
          # Download and extract the ZIP file
          # Add the executable to your PATH
          \`\`\`

          ### Verification

          All binaries are compressed and checksums are provided in \`SHA256SUMS\`.

          \`\`\`bash
          # Verify checksum
          sha256sum -c SHA256SUMS
          \`\`\`

          ### Build Information

          - **Go Version**: ${{ needs.build.outputs.go-version }}
          - **Built on**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          - **Commit**: ${{ github.sha }}
          - **Workflow**: ${{ github.run_id }}

          ---

          **Full Changelog**: [${{ github.repository }}/compare/...](https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }})
          EOF

      - name: Create GitHub Release
        run: |
          MODULE_NAME="${{ needs.build.outputs.module-name }}"
          VERSION="${{ needs.build.outputs.version }}"

          gh release create "${VERSION:-}" \
            ./release-assets/* \
            --title "${MODULE_NAME:-} ${VERSION:-}" \
            --notes-file RELEASE_NOTES.md \
            ${{ contains(needs.build.outputs.version, '-') && '--prerelease' || '' }}

          echo "✅ Release created successfully!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          MODULE_NAME="${{ needs.build.outputs.module-name }}"
          PLATFORMS="${{ needs.build.outputs.platforms }}"

          echo "## Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Module**: ${MODULE_NAME:-}" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.build.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Go Version**: ${{ needs.build.outputs.go-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Assets Released:" >> $GITHUB_STEP_SUMMARY

          for platform in $PLATFORMS; do
            case "$platform" in
              "linux/amd64"|"linux-amd64") echo "- 🐧 Linux AMD64" >> $GITHUB_STEP_SUMMARY ;;
              "windows/amd64"|"windows-amd64") echo "- 🪟 Windows AMD64" >> $GITHUB_STEP_SUMMARY ;;
              "windows/i386"|"windows-i386") echo "- 🪟 Windows i386" >> $GITHUB_STEP_SUMMARY ;;
              "darwin/amd64"|"darwin-amd64") echo "- 🍎 macOS AMD64" >> $GITHUB_STEP_SUMMARY ;;
              "darwin/arm64"|"darwin-arm64") echo "- 🍎 macOS ARM64" >> $GITHUB_STEP_SUMMARY ;;
              *) echo "- 📦 ${platform}" >> $GITHUB_STEP_SUMMARY ;;
            esac
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📄 Release Notes:" >> $GITHUB_STEP_SUMMARY
          cat $(git rev-parse --show-toplevel)/RELEASE_NOTES.md >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
